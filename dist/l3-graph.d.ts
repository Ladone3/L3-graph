// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../../react
//   ../../../three
//   ../../../webcola

declare module 'l3-graph' {
    export { L3Graph, L3GraphProps } from 'l3-graph/l3Graph/l3Graph';
    export { ViewOptions } from 'l3-graph/l3Graph/views/diagramView';
    export { Node, NodeModel, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    export { Link, LinkModel, LinkId } from 'l3-graph/l3Graph/models/graph/link';
    export { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export { NodeDefinition, Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    export { ViewTemplate, LinkViewTemplate, MeshKind, L3Mesh, MeshObj, MeshPrimitive, THREE, DEFAULT_NODE_TEMPLATE, DEFAULT_NODE_TEMPLATE_PROVIDER, DEFAULT_LINK_TEMPLATE, DEFAULT_LINK_TEMPLATE_PROVIDER, OverlayProps, NodeOverlayProps, LinkOverlayProps, TemplateProvider, } from 'l3-graph/l3Graph/customization';
    export { ViewController } from 'l3-graph/l3Graph/controllers/viewController';
    export { applyForceLayout3d } from 'l3-graph/l3Graph/layout/layouts';
    export * from 'l3-graph/l3Graph/utils/subscribable';
    export * from 'l3-graph/l3Graph/utils/colorUtils';
    export { Widget as MeshWidget, WidgetModelContext, WidgetViewContext, WidgetId, } from 'l3-graph/l3Graph/models/widgets/widget';
    export { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    export { GamepadsWidgetView } from 'l3-graph/l3Graph/views/widgets/gamepadsWidgetView';
    export * from 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools';
    export * from 'l3-graph/l3Graph/views/widgets/gamepadTools/editorTools';
    export { FocusNodeWidget } from 'l3-graph/l3Graph/models/widgets/focusNodeWidget';
    export { ReactNodeWidgetView } from 'l3-graph/l3Graph/views/widgets/reactNodeWidgetView';
    export { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    export { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    export * from 'l3-graph/l3Graph/defaultWidgetsSet';
    export { GAMEPAD_BUTTON } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    export { htmlToImage } from 'l3-graph/l3Graph/utils/htmlToSprite';
    export * from 'l3-graph/l3Graph/toolbar';
}

declare module 'l3-graph/l3Graph/l3Graph' {
    import * as React from 'react';
    import { ViewController, ViewControllersSet } from 'l3-graph/l3Graph/controllers/viewController';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { ViewOptions } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector2d, Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { WidgetFactory, Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface L3GraphProps<Descriptor extends GraphDescriptor> {
        viewOptions?: ViewOptions<Descriptor>;
        viewControllers?: ViewControllersSet<Descriptor>;
        onComponentMount?: (graph: L3Graph<Descriptor>) => void;
        onComponentUnmount?: (graph: L3Graph<Descriptor>) => void;
    }
    export class L3Graph<Descriptor extends GraphDescriptor> extends React.Component<L3GraphProps<Descriptor>> {
        constructor(props: L3GraphProps<Descriptor>);
        readonly model: DiagramModel<Descriptor>;
        resize(): void;
        getViewControllers(): ReadonlyArray<ViewController>;
        getViewController(): ViewController;
        setViewController(viewController: ViewController): void;
        attachOverlayToNode(node: Node<Descriptor>, overlay: ReactOverlay<Node<Descriptor>>, position: OverlayPosition): void;
        removeOverlayFromNode(node: Node<Descriptor>, overlayId: string): void;
        componentDidMount(): void;
        componentWillUnmount(): void;
        clientPosTo3dPos(position: Vector2d, distanceFromScreen?: number): Vector3d;
        pos3dToClientPos(position: Vector3d): Vector2d;
        registerWidget<CustomWidget extends Widget>(widgetResolver: WidgetFactory<CustomWidget, Descriptor>): void;
        removeWidget(widgetId: string): void;
        render(): JSX.Element;
    }
}

declare module 'l3-graph/l3Graph/views/diagramView' {
    import * as React from 'react';
    import * as THREE from 'three';
    import { Vector3d, Vector2d } from 'l3-graph/l3Graph/models/structures';
    import { TemplateProvider } from 'l3-graph/l3Graph/customization';
    import { GraphView } from 'l3-graph/l3Graph/views/graph/graphView';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { WidgetsView } from 'l3-graph/l3Graph/views/widgets/widgetsView';
    import { WebGLRenderer } from 'l3-graph/l3Graph/vrUtils/webVr';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { CSS3DRenderer } from 'l3-graph/l3Graph/utils/CSS3DRenderer';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface ViewOptions<Descriptor extends GraphDescriptor> {
        nodeTemplateProvider?: TemplateProvider<Node<Descriptor>>;
        linkTemplateProvider?: TemplateProvider<Link<Descriptor>, Descriptor>;
    }
    export interface DiagramViewProps<Descriptor extends GraphDescriptor> {
        model: DiagramModel<Descriptor>;
        onViewMount?: (view: DiagramView<Descriptor>) => void;
        viewOptions?: ViewOptions<Descriptor>;
    }
    export interface CameraState {
        position: Vector3d;
        focusDirection?: Vector3d;
    }
    export const DEFAULT_CAMERA_DIST = 100;
    export const DEFAULT_SCREEN_PARAMETERS: {
        VIEW_ANGLE: number;
        NEAR: number;
        FAR: number;
    };
    export class DiagramView<Descriptor extends GraphDescriptor> extends React.Component<DiagramViewProps<Descriptor>> {
        renderer: WebGLRenderer;
        overlayRenderer: CSS3DRenderer;
        graphView: GraphView<Descriptor>;
        widgetsView: WidgetsView<any, Descriptor>;
        camera: THREE.PerspectiveCamera;
        scene: THREE.Scene;
        meshHtmlContainer: HTMLElement;
        overlayHtmlContainer: HTMLElement;
        vrManager: VrManager<Descriptor>;
        screenParameters: {
            WIDTH: number;
            HEIGHT: number;
            VIEW_ANGLE: number;
            ASPECT: number;
            NEAR: number;
            FAR: number;
        };
        constructor(props: DiagramViewProps<Descriptor>);
        componentDidMount(): void;
        mouseTo3dPos(event: MouseEvent | TouchEvent, distanceFromScreen?: number): Vector3d;
        clientPosTo3dPos(position: Vector2d, distanceFromScreen?: number): Vector3d;
        pos3dToClientPos(position: Vector3d): Vector2d;
        cameraState: CameraState;
        resize(): void;
        renderGraph(): void;
        render(): JSX.Element;
    }
}

declare module 'l3-graph/l3Graph/models/graph/node' {
    import { Vector3d, Size } from 'l3-graph/l3Graph/models/structures';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { PointEvents, Point, PointParameters, PointId } from 'l3-graph/l3Graph/models/point';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export type NodeId = PointId & {
        nodePlaceholder?: boolean;
    };
    export interface NodeModel<NodeContent> {
        id: NodeId;
        data?: NodeContent;
    }
    export interface NodeParameters extends PointParameters {
        size?: Size;
    }
    export interface NodeEvents extends PointEvents {
        'change:size': Vector3d;
        'force-update': void;
    }
    export class Node<Descriptor extends GraphDescriptor> extends Point<NodeEvents> {
        incomingLinks: Set<Link<Descriptor>>;
        outgoingLinks: Set<Link<Descriptor>>;
        modelIsChanged: boolean;
        readonly id: NodeId;
        constructor(_model: NodeModel<Descriptor['nodeContentType']>, parameters?: NodeParameters);
        readonly data: Descriptor["nodeContentType"];
        setData(data: Descriptor['nodeContentType']): void;
        readonly model: NodeModel<Descriptor['nodeContentType']>;
        readonly size: Size;
        setSize(size: Size): void;
        forceUpdate(): void;
    }
}

declare module 'l3-graph/l3Graph/models/graph/link' {
    import { Node, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export const DEFAULT_LINK_ID = "l3graph-link";
    export type LinkId = string & {
        linkPlaceholder?: boolean;
    };
    export interface LinkModel<LinkContent> {
        id: LinkId;
        sourceId: NodeId;
        targetId: NodeId;
        data?: LinkContent;
    }
    export interface LinkParameters<Descriptor extends GraphDescriptor> {
        source: Node<Descriptor>;
        target: Node<Descriptor>;
    }
    export interface LinkEvents {
        'force-update': void;
    }
    export class Link<Descriptor extends GraphDescriptor> extends Subscribable<LinkEvents> {
        readonly model: LinkModel<Descriptor['linkContentType']>;
        readonly source: Node<Descriptor>;
        readonly target: Node<Descriptor>;
        modelIsChanged: boolean;
        constructor(model: LinkModel<Descriptor['linkContentType']>, parameters: LinkParameters<Descriptor>);
        readonly id: LinkId;
        readonly data: Descriptor["linkContentType"];
        setData(data: Descriptor['linkContentType']): void;
        forceUpdate(): void;
    }
}

declare module 'l3-graph/l3Graph/models/graph/graphDescriptor' {
    export interface DefaultNodeContent {
        label: string;
    }
    export interface DefaultLinkContent {
        label: string;
    }
    export interface GraphDescriptor<NodeContent = any, LinkContent = any> {
        nodeContentType: NodeContent;
        linkContentType: LinkContent;
    }
}

declare module 'l3-graph/l3Graph/models/graph/graphModel' {
    import { Node, NodeModel, NodeParameters, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    import { Link, LinkModel, LinkId } from 'l3-graph/l3Graph/models/graph/link';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export type NodeDefinition<NodeContent> = NodeModel<NodeContent> & NodeParameters;
    export type Element<Descriptor extends GraphDescriptor> = Node<Descriptor> | Link<Descriptor>;
    export type ElementModel<Descriptor extends GraphDescriptor> = NodeModel<Descriptor['nodeContentType']> | LinkModel<Descriptor['linkContentType']>;
    export interface GraphModelEvents<Descriptor extends GraphDescriptor> {
        'add:nodes': Node<Descriptor>[];
        'remove:nodes': Node<Descriptor>[];
        'update:nodes': Node<Descriptor>[];
        'add:links': Link<Descriptor>[];
        'remove:links': Link<Descriptor>[];
        'update:links': Link<Descriptor>[];
    }
    export interface ImmutableMap<K, V> {
        forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
        get(key: K): V | undefined;
        has(key: K): boolean;
        readonly size: number;
    }
    export interface ImmutableSet<T> {
        forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void;
        has(value: T): boolean;
        readonly size: number;
    }
    export class GraphModel<Descriptor extends GraphDescriptor> extends Subscribable<GraphModelEvents<Descriptor>> {
        readonly nodes: ImmutableMap<NodeId, Node<Descriptor>>;
        readonly links: ImmutableMap<LinkId, Link<Descriptor>>;
        getNodeById(id: NodeId): Node<Descriptor>;
        getLinkById(id: LinkId): Link<Descriptor>;
        addNodes(nodes: NodeDefinition<Descriptor['nodeContentType']>[]): void;
        addLinks(models: LinkModel<Descriptor['linkContentType']>[]): void;
        updateNodes(definitions: NodeDefinition<Descriptor['nodeContentType']>[]): void;
        updateLinks(models: LinkModel<Descriptor['linkContentType']>[]): void;
        removeNodes(nodes: Node<Descriptor>[]): void;
        removeLinks(links: Link<Descriptor>[]): void;
    }
}

declare module 'l3-graph/l3Graph/customization' {
    export * from 'l3-graph/l3Graph/customization/defaultLinkTemplate';
    export * from 'l3-graph/l3Graph/customization/defaultNodeTemplate';
    export * from 'l3-graph/l3Graph/customization/defaultOverlay';
    export * from 'l3-graph/l3Graph/customization/mesh';
    export * from 'l3-graph/l3Graph/customization/templates';
}

declare module 'l3-graph/l3Graph/controllers/viewController' {
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector3 } from 'three';
    import { MouseHandler } from 'l3-graph/l3Graph/utils/mouseHandler';
    import { KeyHandler, Subscribable } from 'l3-graph/l3Graph/utils';
    import { GamepadHandler } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export const ROTATION_DECREASE_SPEED = 300;
    export const CAMERA_STEP_SPEED = 20;
    export const ZERO_POSITION: Vector3;
    export const ZOOM_STEP_MULTIPLAYER = 1;
    export const KEY_ROTATION_DECREASE_SPEED = 10;
    export const BORDER_OPACITY = 100;
    export interface ViewControllerEvents {
        'switched:off': void;
        'switched:on': void;
    }
    export interface ViewController extends Subscribable<ViewControllerEvents> {
        id: string;
        label: string;
        switchOn: () => void;
        switchOff: () => void;
        focusOn: (element: Element) => void;
    }
    export type ViewControllersSet<Descriptor extends GraphDescriptor> = ((view: DiagramView<Descriptor>, mouseHandler: MouseHandler<Descriptor>, keyHandler: KeyHandler, gamepadHandler: GamepadHandler<Descriptor>) => ViewController)[];
}

declare module 'l3-graph/l3Graph/layout/layouts' {
    import * as cola from 'webcola';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { GraphModel } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export const PREFERRED_LINK_LENGTH = 75;
    export interface LayoutNode<Descriptor extends GraphDescriptor> {
        id?: string;
        x: number;
        y: number;
        width: number;
        height: number;
        originalNode: Node<Descriptor>;
        bounds?: any;
        innerBounds?: any;
    }
    export interface LayoutLink<Descriptor extends GraphDescriptor> {
        originalLink: Link<Descriptor>;
        source: LayoutNode<Descriptor>;
        target: LayoutNode<Descriptor>;
    }
    export class LayoutNode3D<Descriptor extends GraphDescriptor> extends cola.Node3D {
        node: Node<Descriptor>;
        constructor(node: Node<Descriptor>);
    }
    export class LayoutLink3D<Descriptor extends GraphDescriptor> extends cola.Link3D {
        link: Link<Descriptor>;
        constructor(link: Link<Descriptor>, sourceIndex: number, targetIndex: number);
    }
    export function forceLayout<Descriptor extends GraphDescriptor>(params: {
        iterations: number;
        nodes: LayoutNode<Descriptor>[];
        links: LayoutLink<Descriptor>[];
        preferredLinkLength: number;
    }): void;
    export function forceLayout3d(params: {
        iterations: number;
        nodes: cola.Node3D[];
        links: cola.Link3D[];
        preferredLinkLength: number;
    }): void;
    export function flowLayout<Descriptor extends GraphDescriptor>(params: {
        iterations: number;
        nodes: LayoutNode<Descriptor>[];
        links: LayoutLink<Descriptor>[];
        preferredLinkLength: number;
    }): void;
    export function applyForceLayout<Descriptor extends GraphDescriptor>(graph: GraphModel<Descriptor>): void;
    export function applyForceLayout3d<Descriptor extends GraphDescriptor>(graph: GraphModel<Descriptor>, iterations?: number, linkLength?: number): void;
}

declare module 'l3-graph/l3Graph/utils/subscribable' {
    export interface EventObject<Key, Events> {
        eventId: Key;
        data: Events;
    }
    export type EventCallback<Events, Key extends keyof Events> = (event: EventObject<Key, Events[Key]>) => void;
    export class Subscribable<Events> {
        on<Key extends keyof Events>(eventId: Key, callback: EventCallback<Events, Key>): void;
        onAny(callback: EventCallback<Events, keyof Events>): void;
        unsubscribe<Key extends keyof Events>(eventId: Key, callback: EventCallback<Events, Key>): void;
        unsubscribeFromAll(callback: EventCallback<Events, keyof Events>): void;
        trigger<Key extends keyof Events>(eventId: Key, eventObject?: Events[Key]): void;
    }
    export default Subscribable;
}

declare module 'l3-graph/l3Graph/utils/colorUtils' {
    export function rgbToHex(r: number, g: number, b: number): string;
    /**
        * https://gist.github.com/eyecatchup/9536706
        */
    export function HSVtoRGB(h: number, s: number, v: number): {
            r: number;
            g: number;
            b: number;
    };
    /**
        * Calculate a 32 bit FNV-1a hash
        * https://gist.github.com/vaiorabbit/5657561
        */
    export function hashFnv32a(str: string, seed?: number): number;
}

declare module 'l3-graph/l3Graph/models/widgets/widget' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { MouseHandler } from 'l3-graph/l3Graph/utils/mouseHandler';
    import { KeyHandler } from 'l3-graph/l3Graph/utils';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { GamepadHandler } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export const DEFAULT_SELECTION_TYPE_ID = "l3graph-selection";
    export type WidgetId = string & {
        widgetPlaceholder?: boolean;
    };
    export interface WidgetEvents {
        'update:widget': void;
    }
    export abstract class Widget<Events extends WidgetEvents = WidgetEvents> extends Subscribable<Events> {
        readonly widgetId: WidgetId;
        onRemove?(): void;
        forceUpdate: () => void;
    }
    export interface WidgetModelContext<Descriptor extends GraphDescriptor> {
        diagramModel: DiagramModel<Descriptor>;
        keyHandler: KeyHandler;
        mouseHandler: MouseHandler<Descriptor>;
        gamepadHandler: GamepadHandler<Descriptor>;
        vrManager: VrManager<Descriptor>;
    }
    export interface WidgetViewContext<WidgetModel extends Widget, Descriptor extends GraphDescriptor> {
        diagramView: DiagramView<Descriptor>;
        vrManager: VrManager<Descriptor>;
        widget: WidgetModel;
    }
    export type WidgetModelResolver<WidgetModel extends Widget, Descriptor extends GraphDescriptor> = (context: WidgetModelContext<Descriptor>) => WidgetModel;
    export type WidgetViewResolver<WidgetModel extends Widget, Descriptor extends GraphDescriptor> = (context: WidgetViewContext<WidgetModel, Descriptor>) => DiagramWidgetView;
    export interface WidgetFactory<WidgetModel extends Widget, Descriptor extends GraphDescriptor> {
        getModel: WidgetModelResolver<WidgetModel, Descriptor>;
        getView: WidgetViewResolver<WidgetModel, Descriptor>;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/gamepadsWidget' {
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GamepadHandler } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { GamepadTool } from 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface GamepadsWidgetProps<Descriptor extends GraphDescriptor> {
        gamepadHandler: GamepadHandler<Descriptor>;
        leftTools: GamepadTool[];
        rightTools: GamepadTool[];
    }
    export interface GamepadsTools {
        leftTool: GamepadTool;
        rightTool: GamepadTool;
    }
    export class GamepadsWidget<Descriptor extends GraphDescriptor> extends Widget {
        readonly widgetId: string;
        constructor(props: GamepadsWidgetProps<Descriptor>);
        onRemove(): void;
        readonly tools: GamepadsTools;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadsWidgetView' {
    import * as THREE from 'three';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface GamepadsWidgetViewParameters<Descriptor extends GraphDescriptor> {
        model: GamepadsWidget<Descriptor>;
        vrManager: VrManager<Descriptor>;
    }
    export class GamepadsWidgetView<Descriptor extends GraphDescriptor> implements DiagramWidgetView {
        readonly model: GamepadsWidget<Descriptor>;
        readonly mesh: THREE.Group;
        constructor(parameters: GamepadsWidgetViewParameters<Descriptor>);
        getBoundingBox(): THREE.Box3;
        update(): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools' {
    import * as THREE from 'three';
    import { GamepadHandler, GAMEPAD_BUTTON } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface GamepadToolProps<Descriptor extends GraphDescriptor> {
        gamepadHandler: GamepadHandler<Descriptor>;
        vrManager: VrManager<Descriptor>;
    }
    export interface GamepadToolEvents {
        'update:gamepad': void;
    }
    export abstract class GamepadTool extends Subscribable<GamepadToolEvents> {
        mesh: THREE.Object3D;
        forGamepadId: number;
        constructor();
        protected forceUpdate: () => void;
        abstract onDiscard(): void;
    }
    export class LeftGamepadTool<Descriptor extends GraphDescriptor> extends GamepadTool {
        protected props: GamepadToolProps<Descriptor>;
        protected TARGET_BUTTON: GAMEPAD_BUTTON;
        constructor(props: GamepadToolProps<Descriptor>);
        protected readonly COLOR: string;
        protected registerBearer(): void;
        protected registerHighlighter(): void;
        onDiscard(): void;
    }
    export class RightGamepadTool<Descriptor extends GraphDescriptor> extends LeftGamepadTool<Descriptor> {
        constructor(props: GamepadToolProps<Descriptor>);
        protected TARGET_BUTTON: GAMEPAD_BUTTON;
        protected readonly COLOR: string;
        protected registerBearer(): void;
        protected registerHighlighter(): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadTools/editorTools' {
    import * as THREE from 'three';
    import { GamepadHandler, GAMEPAD_BUTTON } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { EventObject } from 'l3-graph/l3Graph/utils';
    import { GamepadTool } from 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { ImageMesh } from 'l3-graph/l3Graph/views/widgets/gamepadTools/imageMesh';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export const DISPLAY_TARGET_WIDTH = 0.2;
    export const DISPLAY_OFFSET = -5;
    export const MOC_OBJECT_RADIUS = 10;
    export const MOC_OBJECT_NEAR_MARGIN = 20;
    export interface GamepadEditorToolProps<Descriptor extends GraphDescriptor> {
        gamepadHandler: GamepadHandler<Descriptor>;
        diagramModel: DiagramModel<Descriptor>;
        vrManager: VrManager<Descriptor>;
    }
    export class LeftGamepadEditorTool<Descriptor extends GraphDescriptor> extends GamepadTool {
        protected props: GamepadEditorToolProps<Descriptor>;
        protected display: ImageMesh;
        protected mockObject: THREE.Object3D;
        protected readonly BUTTON_CONFIG: {
            pushMock: GAMEPAD_BUTTON;
            pullMock: GAMEPAD_BUTTON;
        };
        protected readonly COLOR: string;
        protected readonly ROTATE_Y_ANGLE: number;
        protected readonly gamepad: THREE.Group;
        constructor(props: GamepadEditorToolProps<Descriptor>);
        setDisplayImage(displayImage: HTMLImageElement): void;
        getTargetPosition(): Vector3d;
        onDiscard(): void;
        protected render: () => void;
        protected onKeyPressed: (e: EventObject<"keyPressed", Map<GAMEPAD_BUTTON, Element<Descriptor>>>) => void;
    }
    export class RightGamepadEditorTool<Descriptor extends GraphDescriptor> extends LeftGamepadEditorTool<Descriptor> {
        constructor(props: GamepadEditorToolProps<Descriptor>);
        protected readonly BUTTON_CONFIG: {
            pushMock: GAMEPAD_BUTTON;
            pullMock: GAMEPAD_BUTTON;
        };
        protected readonly gamepad: THREE.Group;
        protected readonly COLOR: string;
        protected readonly ROTATE_Y_ANGLE: number;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/focusNodeWidget' {
    import { NodeWidget, NodeWidgetParameters } from 'l3-graph/l3Graph/models/widgets/nodeWidget';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface FocusNodeWidgetParameters<Descriptor extends GraphDescriptor> extends NodeWidgetParameters {
        diagramModel: DiagramModel<Descriptor>;
    }
    export class FocusNodeWidget<Descriptor extends GraphDescriptor> extends NodeWidget<Descriptor> {
        constructor(parameters: FocusNodeWidgetParameters<Descriptor>);
    }
}

declare module 'l3-graph/l3Graph/views/widgets/reactNodeWidgetView' {
    import * as THREE from 'three';
    import { FocusNodeWidget } from 'l3-graph/l3Graph/models/widgets/focusNodeWidget';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface ReactNodeWidgetViewParameters<Descriptor extends GraphDescriptor> {
        diagramView: DiagramView<Descriptor>;
        model: FocusNodeWidget<Descriptor>;
        overlay: ReactOverlay<Node<Descriptor>>;
        position?: OverlayPosition;
    }
    export class ReactNodeWidgetView<Descriptor extends GraphDescriptor> implements DiagramWidgetView {
        readonly model: FocusNodeWidget<Descriptor>;
        readonly mesh: THREE.Group;
        constructor(parameters: ReactNodeWidgetViewParameters<Descriptor>);
        getBoundingBox(): THREE.Box3;
        update(): void;
        onRemove(): void;
    }
}

declare module 'l3-graph/l3Graph/views/viewInterface' {
    import * as THREE from 'three';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { AbstractOverlayAnchor } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlay3DAnchor';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface View<Model> {
        readonly mesh: THREE.Object3D | null;
        readonly overlayAnchor3d?: AbstractOverlayAnchor3d<Model, View<Model>>;
        readonly overlayAnchor?: AbstractOverlayAnchor<Model, View<Model>>;
        getBoundingBox(): THREE.Box3;
        update(): void;
        onRemove?(): void;
        model: Model;
    }
    export type DiagramElementView<Descriptor extends GraphDescriptor> = (View<Node<Descriptor>> | View<Link<Descriptor>>);
    export type DiagramWidgetView = View<Widget>;
}

declare module 'l3-graph/l3Graph/views/graph/overlayAnchor' {
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { Box } from 'l3-graph/l3Graph/models/structures';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { CSS3DSprite } from 'l3-graph/l3Graph/utils/CSS3DRenderer';
    export type OverlayPosition = 'nw' | 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w' | 'c';
    export interface OverlayAnchorEvents {
        'anchor:changed': void;
    }
    export abstract class AbstractOverlayAnchor<Model, View> extends Subscribable<OverlayAnchorEvents> {
        protected meshModel: Model;
        protected meshView: View;
        readonly html: HTMLElement;
        readonly _renderedOverlays: Map<string, HTMLElement>;
        readonly _overlayPositions: Map<string, OverlayPosition>;
        readonly sprite: CSS3DSprite;
        protected overlaysByPosition: Map<OverlayPosition, Map<string, ReactOverlay<Model>>>;
        constructor(meshModel: Model, meshView: View);
        readonly overlays: ReadonlyMap<OverlayPosition, ReadonlyMap<string, ReactOverlay<Model>>>;
        hasOverlay(overlayId: string): boolean;
        isVisible(): boolean;
        hide(): void;
        setOverlay(overlay: ReactOverlay<Model>, position: OverlayPosition): void;
        removeOverlay(id: string): void;
        update(): void;
        protected enrichOverlay(poorOverlay: ReactOverlay<Model>): ReactOverlay<Model>;
        protected overlayedGroup: (props: any) => JSX.Element;
        abstract getModelFittingBox(): Box;
    }
}

declare module 'l3-graph/l3Graph/defaultWidgetsSet' {
    import { SelectionWidget } from 'l3-graph/l3Graph/models/widgets/selectionWidget';
    import { ArrowHelper } from 'l3-graph/l3Graph/models/widgets/arrowHelper';
    import { WidgetFactory } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export const selectionWidgetFactory: WidgetFactory<SelectionWidget<any>, any>;
    export const arrowHelperWidgetFactory: WidgetFactory<ArrowHelper<any>, any>;
    export const gamepadsWidgetFactory: WidgetFactory<GamepadsWidget<any>, any>;
    export const testToolFactory: WidgetFactory<any, any>;
    export function DEFAULT_MESH_WIDGET_SET<Descriptor extends GraphDescriptor>(): WidgetFactory<any, Descriptor>[];
}

declare module 'l3-graph/l3Graph/vrUtils/gamepadHandler' {
    import * as THREE from 'three';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export type Controller = THREE.Group;
    /**
      * This function should return
      * the function which restore the initial state of the highlighted mesh
      */
    export type Highlighter = (mesh: THREE.Object3D) => (mesh: THREE.Object3D) => void;
    export interface ElementBearer {
        dragKey: GAMEPAD_BUTTON;
        dragToKey: GAMEPAD_BUTTON;
        dragFromKey: GAMEPAD_BUTTON;
    }
    export interface GamepadDragEventData<Descriptor extends GraphDescriptor> {
        target: Element<Descriptor>;
        position: Vector3d;
    }
    export interface GamepadHandlerEvents<Descriptor extends GraphDescriptor> {
        'keyDown': Map<GAMEPAD_BUTTON, Element<Descriptor> | undefined>;
        'keyUp': Map<GAMEPAD_BUTTON, Element<Descriptor> | undefined>;
        'keyPressed': Map<GAMEPAD_BUTTON, Element<Descriptor> | undefined>;
        'elementDragStart': GamepadDragEventData<Descriptor>;
        'elementDrag': GamepadDragEventData<Descriptor>;
        'elementDragEnd': GamepadDragEventData<Descriptor>;
    }
    export const GAMEPAD_EXTRA_MOVE_STEP = 10;
    export enum GAMEPAD_BUTTON {
        LEFT_NIPPLE = "LEFT_NIPPLE",
        RIGHT_NIPPLE = "RIGHT_NIPPLE",
        LEFT_TRIGGER = "LEFT_TRIGGER",
        RIGHT_TRIGGER = "RIGHT_TRIGGER",
        LEFT_GRUBBER = "LEFT_GRUBBER",
        RIGHT_GRUBBER = "RIGHT_GRUBBER",
        A = "A",
        B = "B",
        X = "X",
        Y = "Y",
        OCULUS = "OCULUS",
        MENU = "MENU"
    }
    export const OCULUS_CONTROLLERS: {
        LEFT_CONTROLLER: number;
        RIGHT_CONTROLLER: number;
    };
    export const CONTROLLERS_NUMBER: number;
    export class GamepadHandler<Descriptor extends GraphDescriptor> extends Subscribable<GamepadHandlerEvents<Descriptor>> {
        readonly keyPressed: Map<GAMEPAD_BUTTON, Element<Descriptor>>;
        constructor(diagramModel: DiagramModel<Descriptor>, diagramView: DiagramView<Descriptor>);
        registerHighlighter(controller: Controller, highlighter: Highlighter): void;
        registerElementBearer(controller: Controller, bearer: ElementBearer): void;
    }
    export function attach(child: THREE.Object3D, to: THREE.Object3D, scene: THREE.Scene): void;
    export function detach(child: THREE.Object3D, parent: THREE.Object3D, scene: THREE.Scene): void;
    export function _attach(child: THREE.Object3D, scene: THREE.Scene, parent: THREE.Object3D): void;
}

declare module 'l3-graph/l3Graph/utils/htmlToSprite' {
    import * as THREE from 'three';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Vector2d } from 'l3-graph/l3Graph/models/structures';
    export interface Rendered3dSprite {
        sprite: THREE.Sprite;
        position: OverlayPosition;
        size: Vector2d;
    }
    export function createSprite(htmlOverlay: HTMLElement, position: OverlayPosition): Promise<Rendered3dSprite>;
    export function htmlToImage(htmlElement: HTMLElement): Promise<HTMLImageElement>;
}

declare module 'l3-graph/l3Graph/toolbar' {
    import * as React from 'react';
    import { ViewController } from 'l3-graph/l3Graph/controllers/viewController';
    export interface ToolbarProps {
        viewControllers: ReadonlyArray<ViewController>;
        defaultViewController?: ViewController;
        onChangeViewController: (viewController: ViewController) => void;
        onApplyLayout: () => void;
    }
    interface State {
        selectedViewController: ViewController | undefined;
    }
    export class Toolbar extends React.Component<ToolbarProps, State> {
        constructor(props: ToolbarProps);
        componentDidMount(): void;
        setViewController(selectedViewController: ViewController): void;
        render(): JSX.Element;
    }
    export {};
}

declare module 'l3-graph/l3Graph/models/diagramModel' {
    import { GraphModel, ImmutableMap } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Node, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    import { Link, LinkId } from 'l3-graph/l3Graph/models/graph/link';
    import { WidgetsModel } from 'l3-graph/l3Graph/models/widgets/widgetsModel';
    import { Selection } from 'l3-graph/l3Graph/models/widgets/selection';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface NodeEvent<Descriptor extends GraphDescriptor> {
        type: 'add:node' | 'remove:node' | 'update:node';
        target: Node<Descriptor>;
    }
    export interface LinkEvent<Descriptor extends GraphDescriptor> {
        type: 'add:link' | 'remove:link' | 'update:link';
        target: Link<Descriptor>;
    }
    export interface WidgetEvent {
        type: 'add:widget' | 'remove:widget' | 'update:widget';
        target: Widget;
    }
    export interface DiagramEvents<Descriptor extends GraphDescriptor> {
        nodeEvents: ReadonlyArray<NodeEvent<Descriptor>>;
        linkEvents: ReadonlyArray<LinkEvent<Descriptor>>;
        widgetEvents: ReadonlyArray<WidgetEvent>;
    }
    export interface DiagramModelEvents<Descriptor extends GraphDescriptor> {
        'syncupdate': DiagramEvents<Descriptor>;
    }
    export class DiagramModel<Descriptor extends GraphDescriptor> extends Subscribable<DiagramModelEvents<Descriptor>> {
        graph: GraphModel<Descriptor>;
        widgetRegistry: WidgetsModel;
        selection: Selection<Descriptor>;
        constructor();
        readonly nodes: ImmutableMap<NodeId, Node<Descriptor>>;
        readonly links: ImmutableMap<LinkId, Link<Descriptor>>;
        performSyncUpdate: () => void;
    }
}

declare module 'l3-graph/l3Graph/models/structures' {
    export interface Vector3d {
        x: number;
        y: number;
        z: number;
    }
    export interface Vector2d {
        x: number;
        y: number;
    }
    export type Size = Vector3d & {
        placeholder?: boolean;
    };
    export interface Rectangle extends Vector2d {
        width: number;
        height: number;
    }
    export interface Box extends Vector3d {
        width: number;
        height: number;
        deep: number;
    }
    export enum Object3dKind {
        Mesh = "mesh",
        Line = "line"
    }
    export type Polygon3d = [Vector3d, Vector3d, Vector3d];
    export interface Mesh {
        type: Object3dKind.Mesh;
        polygons: Polygon3d[];
    }
    export interface Line {
        type: Object3dKind.Line;
        points: Vector3d[];
    }
}

declare module 'l3-graph/l3Graph/views/graph/graphView' {
    import * as THREE from 'three';
    import { GraphModel, Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { NodeView } from 'l3-graph/l3Graph/views/graph/nodeView';
    import { LinkView } from 'l3-graph/l3Graph/views/graph/linkView';
    import { TemplateProvider } from 'l3-graph/l3Graph/customization';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { Link, LinkId } from 'l3-graph/l3Graph/models/graph/link';
    import { Node, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    import { LinkRouter } from 'l3-graph/l3Graph/utils/linkRouter';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlay3DAnchor';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface GraphViewProps<Descriptor extends GraphDescriptor> {
        graphModel: GraphModel<Descriptor>;
        vrManager: VrManager<Descriptor>;
        onAdd3dObject: (object: THREE.Object3D) => void;
        onRemove3dObject: (object: THREE.Object3D) => void;
        nodeTemplateProvider?: TemplateProvider<Node<Descriptor>>;
        linkTemplateProvider?: TemplateProvider<Link<Descriptor>, Descriptor>;
        simpleLinks?: boolean;
    }
    export interface GraphViewEvents<Descriptor extends GraphDescriptor> {
        'overlay:down': {
            event: MouseEvent | TouchEvent;
            target: Element<Descriptor>;
        };
    }
    export class GraphView<Descriptor extends GraphDescriptor> extends Subscribable<GraphViewEvents<Descriptor>> {
        nodeViews: Map<NodeId, NodeView<Descriptor>>;
        linkViews: Map<LinkId, LinkView<Descriptor>>;
        anchors3d: Set<AbstractOverlayAnchor3d<any, any>>;
        graphModel: GraphModel<Descriptor>;
        meshHtmlContainer: HTMLElement;
        overlayHtmlContainer: HTMLElement;
        linkRouter: LinkRouter<Descriptor>;
        constructor(props: GraphViewProps<Descriptor>);
        registerNode(node: Node<Descriptor>): NodeView<Descriptor>;
        registerLink(link: Link<Descriptor>): LinkView<Descriptor>;
        removeNodeView(node: Node<Descriptor>): void;
        removeLinkView(link: Link<Descriptor>): void;
        update({ updatedNodeIds, updatedLinkIds }: {
            updatedNodeIds: NodeId[];
            updatedLinkIds: LinkId[];
        }): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/widgetsView' {
    import * as THREE from 'three';
    import { WidgetsModel } from 'l3-graph/l3Graph/models/widgets/widgetsModel';
    import { WidgetViewResolver, Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface WidgetsViewProps<Descriptor extends GraphDescriptor> {
        diagramView: DiagramView<Descriptor>;
        vrManager: VrManager<Descriptor>;
        widgetsModel: WidgetsModel;
        onAdd3dObject: (object: THREE.Object3D) => void;
        onRemove3dObject: (object: THREE.Object3D) => void;
    }
    export class WidgetsView<CustomWidget extends Widget, Descriptor extends GraphDescriptor> {
        diagramView: DiagramView<Descriptor>;
        vrManager: VrManager<Descriptor>;
        widgetsModel: WidgetsModel;
        constructor(props: WidgetsViewProps<Descriptor>);
        registerViewResolver(widgetId: string, viewResolver: WidgetViewResolver<CustomWidget, Descriptor>): void;
        registerWidgetViewForModel(widget: CustomWidget): void;
        removeWidgetViewOfModel(widget: Widget): void;
        update(specificIds?: string[]): void;
    }
}

declare module 'l3-graph/l3Graph/vrUtils/webVr' {
    import * as THREE from 'three';
    export interface UndocumentedOptions {
        frameOfReferenceType: any;
    }
    export interface WebGLRenderer extends THREE.WebGLRenderer {
        vr: ThreejsVrManager;
    }
    export interface ThreejsVrManager extends THREE.WebVRManager {
        setSession: (session: Session) => void;
        getController: (index: number) => THREE.Group;
        scaleFactor: number;
    }
    export type Device = VRDisplay & {
        isPresenting: boolean;
        exitPresent: () => void;
        requestPresent: (presenters: {
            source: HTMLCanvasElement;
        }[]) => void;
        requestSession: (options: {
            immersive: boolean;
            exclusive: boolean;
        }) => Promise<Session>;
        supportsSession: (options: {
            immersive: boolean;
            exclusive: boolean;
        }) => Promise<void>;
    };
    export interface VrEvent extends Event {
        display: Device;
    }
    export interface Session {
        addEventListener: (eventId: string, handler: (event: Event) => void) => void;
        removeEventListener: (eventId: string, handler: (event: Event) => void) => void;
        end: () => void;
    }
    export interface XrNavigator extends Navigator {
        xr: {
            requestDevice: () => Promise<Device>;
        };
    }
    export interface CompleteNavigator extends Navigator {
        webkitGetGamepads: () => Gamepad[];
    }
    export function isXrNavigator(n: Navigator): n is XrNavigator;
    export function isWebkitNavigator(n: Navigator): n is CompleteNavigator;
}

declare module 'l3-graph/l3Graph/vrUtils/vrManager' {
    import Subscribable from 'l3-graph/l3Graph/utils/subscribable';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface VrManagerEvents {
        'presenting:state:changed': void;
        'connection:state:changed': void;
    }
    export class VrManager<Descriptor extends GraphDescriptor> extends Subscribable<VrManagerEvents> {
        constructor(view: DiagramView<Descriptor>);
        readonly errors: string[];
        readonly isStarted: boolean;
        readonly isConnected: boolean;
        readonly camera: import("three").PerspectiveCamera | import("three").ArrayCamera;
        getController(id: number): import("three").Group;
        start(): void;
        stop(): void;
        connect(): Promise<void>;
    }
}

declare module 'l3-graph/l3Graph/utils/CSS3DRenderer' {
    import * as THREE from 'three';
    /**
      * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
      * @author mrdoob / http://mrdoob.com/
      * @author yomotsu / https://yomotsu.net/
      */
    export class CSS3DObject extends THREE.Object3D {
        element: HTMLElement;
        constructor(element: HTMLElement);
    }
    export class CSS3DSprite extends CSS3DObject {
        element: HTMLElement;
        constructor(element: HTMLElement);
    }
    export class CSS3DRenderer {
        _width: number;
        _height: number;
        _widthHalf: number;
        _heightHalf: number;
        matrix: THREE.Matrix4;
        cache: {
            camera: {
                fov: number;
                style: string;
            };
            objects: WeakMap<object, any>;
        };
        domElement: HTMLDivElement;
        cameraElement: HTMLDivElement;
        isIE: boolean;
        constructor();
        getSize(): {
            width: number;
            height: number;
        };
        setSize(width: number, height: number): void;
        render(scene: THREE.Scene, camera: THREE.Camera): void;
    }
}

declare module 'l3-graph/l3Graph/models/point' {
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    export type PointId = string & {
        pointPlaceholder?: boolean;
    };
    export interface PointParameters {
        position: Vector3d;
    }
    export interface PointEvents {
        'change:position': Vector3d;
    }
    export abstract class Point<Events extends PointEvents = PointEvents> extends Subscribable<Events> {
        readonly id: PointId;
        protected _position: Vector3d;
        constructor(parameters: PointParameters);
        readonly position: Vector3d;
        setPosition(position: Vector3d): void;
    }
}

declare module 'l3-graph/l3Graph/customization/defaultLinkTemplate' {
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { LinkViewTemplate, TemplateProvider } from 'l3-graph/l3Graph/customization/templates';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    export const DEFAULT_LINK_TEMPLATE: LinkViewTemplate<GraphDescriptor>;
    export const DEFAULT_LINK_TEMPLATE_PROVIDER: TemplateProvider<Link<GraphDescriptor>, GraphDescriptor>;
}

declare module 'l3-graph/l3Graph/customization/defaultNodeTemplate' {
    import { ViewTemplate, TemplateProvider } from 'l3-graph/l3Graph/customization/templates';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    export const DEFAULT_NODE_TEMPLATE: ViewTemplate<Node<GraphDescriptor>>;
    export const DEFAULT_NODE_TEMPLATE_PROVIDER: TemplateProvider<Node<GraphDescriptor>>;
}

declare module 'l3-graph/l3Graph/customization/defaultOverlay' {
    import * as React from 'react';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization/templates';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    export const DEFAULT_NODE_OVERLAY: ReactOverlay<Node<GraphDescriptor>>;
    export const DEFAULT_LINK_OVERLAY: ReactOverlay<Link<GraphDescriptor>>;
    export function createContextProvider(context: any): React.ComponentClass;
    export function enrichOverlay<Model>(poorOverlay: ReactOverlay<Model>, data: Model): ReactOverlay<Model>;
}

declare module 'l3-graph/l3Graph/customization/mesh' {
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    export enum MeshKind {
        Obj = "obj",
        Primitive = "primitive",
        ThreeNative = "three-native"
    }
    export namespace THREE {
        type Object3D = any;
    }
    export interface Mesh {
        color?: string | number;
        texture?: string;
        preserveRatio?: boolean;
        size?: Vector3d;
    }
    export interface MeshNative extends Mesh {
        type: MeshKind.ThreeNative;
        mesh: THREE.Object3D;
    }
    export interface MeshObj extends Mesh {
        type: MeshKind.Obj;
        markup: string;
    }
    export interface MeshPrimitive extends Mesh {
        type: MeshKind.Primitive;
        shape: 'cube' | 'sphere' | 'cone' | 'cylinder' | 'dodecahedron' | 'torus' | 'tetrahedron' | 'plane';
    }
    export type L3Mesh = MeshNative | MeshObj | MeshPrimitive;
}

declare module 'l3-graph/l3Graph/customization/templates' {
    import * as React from 'react';
    import { L3Mesh } from 'l3-graph/l3Graph/customization/mesh';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    export interface OverlayProps<Model> {
        target?: Model;
    }
    export type NodeOverlayProps<Descriptor extends GraphDescriptor> = OverlayProps<Node<Descriptor>>;
    export type LinkOverlayProps<Descriptor extends GraphDescriptor> = OverlayProps<Link<Descriptor>>;
    export interface ReactOverlay<Model> {
        id: string;
        value: React.ReactElement<OverlayProps<Model>>;
        context?: any;
    }
    export interface ViewTemplate<Model> {
        overlay?: ReactOverlay<Model>;
        mesh?: () => L3Mesh;
    }
    export interface LinkViewTemplate<Descriptor extends GraphDescriptor> {
        color: number | string;
        thickness?: number;
        overlay?: ReactOverlay<Link<Descriptor>>;
    }
    export type ProviderTemplateType<Model, Descriptor extends GraphDescriptor = GraphDescriptor> = Model extends Link<Descriptor> ? LinkViewTemplate<Descriptor> : ViewTemplate<Model>;
    export type TemplateProvider<Model, Descriptor extends GraphDescriptor = GraphDescriptor> = (model: Model) => ProviderTemplateType<Model, Descriptor>;
}

declare module 'l3-graph/l3Graph/utils/mouseHandler' {
    import * as THREE from 'three';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector2d } from 'l3-graph/l3Graph/models/structures';
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export const MIN_DRAG_OFFSET = 5;
    export interface HandlerElementClickEvent<Descriptor extends GraphDescriptor> {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        element: Element<Descriptor>;
    }
    export interface HandlerDragElementEvent<Descriptor extends GraphDescriptor> {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        element: Element<Descriptor>;
    }
    export interface HandlerDragEvent {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        offset: Vector2d;
    }
    export interface MouseHandlerEvents<Descriptor extends GraphDescriptor> {
        'elementScroll': HandlerElementClickEvent<Descriptor>;
        'paperScroll': MouseWheelEvent;
        'elementClick': HandlerElementClickEvent<Descriptor>;
        'paperClick': MouseEvent | TouchEvent;
        'elementStartDrag': HandlerDragElementEvent<Descriptor>;
        'elementDrag': HandlerDragElementEvent<Descriptor>;
        'elementEndDrag': HandlerDragElementEvent<Descriptor>;
        'paperStartDrag': HandlerDragEvent;
        'paperDrag': HandlerDragEvent;
        'paperEndDrag': HandlerDragEvent;
    }
    export class MouseHandler<Descriptor extends GraphDescriptor> extends Subscribable<MouseHandlerEvents<Descriptor>> {
        constructor(diagramModel: DiagramModel<Descriptor>, diagramView: DiagramView<Descriptor>);
        readonly isPanning: boolean;
        readonly isDragging: boolean;
        readonly draggedElement: Element<Descriptor> | undefined;
        fireMouseDownEvent(event: MouseEvent | TouchEvent, element?: Element<Descriptor>): void;
        fireScrollEvent(event: MouseWheelEvent, element?: Element<Descriptor>): void;
    }
    export function mapMeshes<Descriptor extends GraphDescriptor>(diagramModel: DiagramModel<Descriptor>, diagramView: DiagramView<Descriptor>): {
        meshes: THREE.Object3D[];
        nodeMeshMap: Element<Descriptor>[];
    };
    export function handleDragging(downEvent: MouseEvent | TouchEvent, onChange: (event: MouseEvent | TouchEvent, change: Vector2d) => void, onEnd?: (event: MouseEvent | TouchEvent, change?: Vector2d) => void): void;
}

declare module 'l3-graph/l3Graph/utils' {
    export * from 'l3-graph/l3Graph/utils/colorUtils';
    export * from 'l3-graph/l3Graph/utils/keyHandler';
    export * from 'l3-graph/l3Graph/utils/shapeUtils';
    export * from 'l3-graph/l3Graph/utils/subscribable';
    export * from 'l3-graph/l3Graph/utils/geometry';
    /** Generates random 32-digit hexadecimal string. */
    export function generate128BitID(): string;
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadTools/imageMesh' {
    import * as THREE from 'three';
    import { Vector2d } from 'l3-graph/l3Graph/models/structures';
    export interface ImageMeshParameters {
        size?: Partial<Vector2d>;
        image?: HTMLImageElement;
    }
    export class ImageMesh extends THREE.Group {
        constructor(parameters?: ImageMeshParameters);
        setImage(image: HTMLImageElement | undefined): void;
        setPreferredSize(size: Vector2d | undefined): void;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/nodeWidget' {
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { WidgetEvents, Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface NodeWidgetEvents<Descriptor extends GraphDescriptor> extends WidgetEvents {
        'change:focus': Node<Descriptor>;
    }
    export interface NodeWidgetParameters {
        widgetId: string;
    }
    export abstract class NodeWidget<Descriptor extends GraphDescriptor> extends Widget {
        readonly widgetId: string;
        constructor(parameters: NodeWidgetParameters);
        setFocusNode(target: Node<Descriptor> | undefined): void;
        readonly isFocusNodeChanged: boolean;
        readonly focusNode: Node<Descriptor>;
        readonly prevFocusNode: Node<Descriptor>;
        onRemove(): void;
    }
}

declare module 'l3-graph/l3Graph/views/graph/overlay3DAnchor' {
    import * as THREE from 'three';
    import { Rendered3dSprite } from 'l3-graph/l3Graph/utils/htmlToSprite';
    import { AbstractOverlayAnchor, OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    export abstract class AbstractOverlayAnchor3d<Model, View> {
        protected meshModel: Model;
        protected meshView: View;
        protected overlayAnchor: AbstractOverlayAnchor<Model, View>;
        readonly mesh: THREE.Object3D;
        sprites: Rendered3dSprite[];
        constructor(meshModel: Model, meshView: View, overlayAnchor: AbstractOverlayAnchor<Model, View>);
        update(): void;
        abstract forceUpdate(): void;
        abstract updatePosition(): void;
        abstract placeSprites(sprites: Rendered3dSprite[]): void;
    }
    export function applyOffset(basicVector: Vector3d, offset: Vector3d, position: OverlayPosition): Vector3d;
}

declare module 'l3-graph/l3Graph/models/widgets/selectionWidget' {
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface SelectionParameters<Descriptor extends GraphDescriptor> {
        diagramModel: DiagramModel<Descriptor>;
    }
    export class SelectionWidget<Descriptor extends GraphDescriptor> extends Widget {
        readonly widgetId: string;
        constructor(parameters: SelectionParameters<Descriptor>);
        readonly selectedElements: Element<Descriptor>[];
    }
}

declare module 'l3-graph/l3Graph/models/widgets/arrowHelper' {
    import { NodeWidget } from 'l3-graph/l3Graph/models/widgets/nodeWidget';
    import { MouseHandler } from 'l3-graph/l3Graph/utils/mouseHandler';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface ArrowHelperParameters<Descriptor extends GraphDescriptor> {
        mouseHandler: MouseHandler<Descriptor>;
    }
    export class ArrowHelper<Descriptor extends GraphDescriptor> extends NodeWidget<Descriptor> {
        constructor(parameters: ArrowHelperParameters<Descriptor>);
        readonly isVisible: boolean;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/widgetsModel' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    export interface WidgetsModelEvents {
        'add:widget': Widget;
        'remove:widget': Widget;
        'update:widget': Widget;
    }
    export class WidgetsModel extends Subscribable<WidgetsModelEvents> {
        readonly widgets: ReadonlyMap<string, Widget>;
        registerWidget(widget: Widget): void;
        removeWidget(widget: Widget): void;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/selection' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { GraphModel } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface SelectionParameters<Descriptor extends GraphDescriptor> {
        selection?: Set<Node<Descriptor>>;
        graph: GraphModel<Descriptor>;
    }
    export interface SelectionEvents<Descriptor extends GraphDescriptor> {
        'change': ReadonlySet<Node<Descriptor>>;
    }
    export class Selection<Descriptor extends GraphDescriptor> extends Subscribable<SelectionEvents<Descriptor>> {
        readonly widgetId: string;
        constructor(parameters: SelectionParameters<Descriptor>);
        setSelection(nodes: ReadonlySet<Node<Descriptor>>): void;
        readonly elements: ReadonlySet<Node<Descriptor>>;
    }
}

declare module 'l3-graph/l3Graph/views/graph/nodeView' {
    import * as THREE from 'three';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { ViewTemplate, ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { AbstractOverlayAnchor } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { View } from 'l3-graph/l3Graph/views/viewInterface';
    import { AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlay3DAnchor';
    import { Rendered3dSprite } from 'l3-graph/l3Graph/utils/htmlToSprite';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export class NodeView<Descriptor extends GraphDescriptor> implements View<Node<Descriptor>> {
        readonly model: Node<Descriptor>;
        readonly mesh: THREE.Object3D;
        readonly overlayAnchor: NodeOverlayAnchor<Descriptor>;
        readonly overlayAnchor3d: NodeOverlayAnchor3d<Descriptor>;
        constructor(model: Node<Descriptor>, template: ViewTemplate<Node<Descriptor>>);
        getBoundingBox(): THREE.Box3;
        update(): void;
    }
    export class NodeOverlayAnchor<Descriptor extends GraphDescriptor> extends AbstractOverlayAnchor<Node<Descriptor>, NodeView<Descriptor>> {
        getModelFittingBox(): {
            width: number;
            height: number;
            deep: number;
            x: number;
            y: number;
            z: number;
        };
        protected enrichOverlay(poorOverlay: ReactOverlay<Node<Descriptor>>): ReactOverlay<Node<Descriptor>>;
    }
    export class NodeOverlayAnchor3d<Descriptor extends GraphDescriptor> extends AbstractOverlayAnchor3d<Node<Descriptor>, NodeView<Descriptor>> {
        forceUpdate(): void;
        updatePosition(): void;
        placeSprites(renderedSprites: Rendered3dSprite[]): void;
    }
}

declare module 'l3-graph/l3Graph/views/graph/linkView' {
    import * as THREE from 'three';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { LinkViewTemplate } from 'l3-graph/l3Graph/customization';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { AbstractOverlayAnchor } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { LinkRouter } from 'l3-graph/l3Graph/utils/linkRouter';
    import { View } from 'l3-graph/l3Graph/views/viewInterface';
    import { AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlay3DAnchor';
    import { Rendered3dSprite } from 'l3-graph/l3Graph/utils/htmlToSprite';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export class LinkView<Descriptor extends GraphDescriptor> implements View<Link<Descriptor>> {
        readonly model: Link<Descriptor>;
        readonly router: LinkRouter<Descriptor>;
        readonly mesh: THREE.Group;
        readonly overlayAnchor: LinkOverlayAnchor<Descriptor>;
        readonly overlayAnchor3d: LinkOverlayAnchor3d<Descriptor>;
        polyline: Vector3d[];
        constructor(model: Link<Descriptor>, router: LinkRouter<Descriptor>, template: LinkViewTemplate<Descriptor>);
        getBoundingBox(): THREE.Box3;
        update(): void;
    }
    export class LinkOverlayAnchor<Descriptor extends GraphDescriptor> extends AbstractOverlayAnchor<Link<Descriptor>, LinkView<Descriptor>> {
        getModelFittingBox(): {
            x: number;
            y: number;
            z: number;
            width: number;
            height: number;
            deep: number;
        };
        protected overlayedGroup: (props: any) => JSX.Element;
    }
    export class LinkOverlayAnchor3d<Descriptor extends GraphDescriptor> extends AbstractOverlayAnchor3d<Link<Descriptor>, LinkView<Descriptor>> {
        forceUpdate(): void;
        updatePosition(): void;
        placeSprites(renderedSprites: Rendered3dSprite[]): void;
    }
}

declare module 'l3-graph/l3Graph/utils/linkRouter' {
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface LinkRouter<Descriptor extends GraphDescriptor> {
            getRout(link: Link<Descriptor>): Vector3d[];
    }
    export class DefaultLinkRouter<Descriptor extends GraphDescriptor> implements LinkRouter<Descriptor> {
            getRout(link: Link<Descriptor>): Vector3d[];
    }
    /**
        * @param polyline
        * @param offset from 0 to 1
        */
    export function getPointAlongPolylineByRatio(polyline: ReadonlyArray<Vector3d>, ratio: number): Vector3d;
    /**
        * @param polyline
        * @param offset from 0 to length of polyline
        */
    export function getPointAlongPolyline(polyline: ReadonlyArray<Vector3d>, offset: number): Vector3d;
    export function computePolylineLength(polyline: ReadonlyArray<Vector3d>): number;
}

declare module 'l3-graph/l3Graph/utils/keyHandler' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    export interface KeyHandlerEvents {
        'keyDown': Set<number>;
        'keyPressed': Set<number>;
        'keyUp': Set<number>;
    }
    export const KEY_CODES: {
        UP: number;
        DOWN: number;
        LEFT: number;
        RIGHT: number;
        SPACE: number;
        CTRL: number;
        PLUS: number;
        MINUS: number;
        DELETE: number;
        ESCAPE: number;
    };
    export class KeyHandler extends Subscribable<KeyHandlerEvents> {
        switchOn(): void;
        switchOff(): void;
    }
    export interface CancellationEvents {
        'cancel': void;
    }
    export class Cancellation extends Subscribable<CancellationEvents> {
        isCancelled: boolean;
        stop(): void;
    }
    export function animationFrameInterval(intervalCallback: () => void): Cancellation;
}

declare module 'l3-graph/l3Graph/utils/shapeUtils' {
    import * as THREE from 'three';
    import { MeshPrimitive, MeshObj } from 'l3-graph/l3Graph/customization';
    export function preparePrimitive(primitive: MeshPrimitive): THREE.Mesh;
    export function prepareMesh(meshObj: MeshObj): THREE.Object3D;
    /** Helper only for phong and line basic material */
    export function setColor(mesh: THREE.Object3D, providedColor: string | number | Map<THREE.Object3D, string | number>): void;
    export function setMaterial(mesh: THREE.Object3D, material: THREE.Material): void;
    export function backupColors(mesh: THREE.Object3D): Map<THREE.Object3D, THREE.Material | THREE.Material[]>;
    export function restoreColors(mesh: THREE.Object3D, backUp: Map<THREE.Object3D, THREE.Material | THREE.Material[]>): void;
}

declare module 'l3-graph/l3Graph/utils/geometry' {
    import * as THREE from 'three';
    import { Vector3d, Vector2d, Size } from 'l3-graph/l3Graph/models/structures';
    export function vector3dToTreeVector3(v: Vector3d): THREE.Vector3;
    export function threeVector3ToVector3d(v: THREE.Vector3): Vector3d;
    export function calcBounds(points: Vector3d[]): {
        min: Vector3d;
        max: Vector3d;
        average: Vector3d;
    };
    export function normalize(vector: Vector3d): Vector3d;
    export function length(from: Vector3d | Vector2d): number;
    export function vectorLength({ x, y, z }: Vector3d): number;
    export function distance(from: Vector3d | Vector2d, to: Vector3d | Vector2d): number;
    export function inverse(vector: Vector3d): Vector3d;
    export function multiply(vector: Vector3d, k: number): Vector3d;
    export function sum(vector1: Vector3d, vector2: Vector3d): Vector3d;
    export function sub(vector1: Vector3d, vector2: Vector3d): Vector3d;
    export function normalLeft(vector: Vector3d): {
        x: number;
        y: number;
        z: number;
    };
    export function normalUp(vector: Vector3d): Vector3d;
    export function normalDown(vector: Vector3d): Vector3d;
    export function normalRight(vector: Vector3d): Vector3d;
    export function eventToPosition(event: MouseEvent | TouchEvent, viewBox?: ClientRect | DOMRect): Vector2d | undefined;
    export function getModelFittingBox({ x, y, z }: Size): {
        width: number;
        height: number;
        deep: number;
    };
}

