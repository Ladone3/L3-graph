// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../../react
//   ../../../three
//   ../../../webcola

declare module 'l3-graph' {
    export { L3Graph, L3GraphProps } from 'l3-graph/l3Graph/l3Graph';
    export { ViewOptions } from 'l3-graph/l3Graph/views/diagramView';
    export { Node, NodeModel, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    export { Link, LinkModel, LinkId } from 'l3-graph/l3Graph/models/graph/link';
    export { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export { NodeDefinition, Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    export { ViewTemplate, LinkViewTemplate, MeshKind, L3Mesh, MeshObj, MeshPrimitive, THREE, DEFAULT_NODE_TEMPLATE, DEFAULT_NODE_TEMPLATE_PROVIDER, DEFAULT_LINK_TEMPLATE, DEFAULT_LINK_TEMPLATE_PROVIDER, OverlayProps, NodeOverlayProps, LinkOverlayProps, TemplateProvider, } from 'l3-graph/l3Graph/customization';
    export { ViewController } from 'l3-graph/l3Graph/controllers/viewController';
    export { applyForceLayout3d } from 'l3-graph/l3Graph/layout/layouts';
    export * from 'l3-graph/l3Graph/utils/subscribable';
    export * from 'l3-graph/l3Graph/utils/colorUtils';
    export { Widget as MeshWidget, WidgetModelContext, WidgetViewContext, WidgetId, } from 'l3-graph/l3Graph/models/widgets/widget';
    export { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    export { GamepadsWidgetView } from 'l3-graph/l3Graph/views/widgets/gamepadsWidgetView';
    export * from 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools';
    export { FocusNodeWidget } from 'l3-graph/l3Graph/models/widgets/focusNodeWidget';
    export { ReactNodeWidgetView } from 'l3-graph/l3Graph/views/widgets/reactNodeWidgetView';
    export { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    export { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    export * from 'l3-graph/l3Graph/defaultWidgetsSet';
    export { GAMEPAD_BUTTON } from 'l3-graph/l3Graph/input/gamepadHandler';
    export { htmlToImage } from 'l3-graph/l3Graph/utils/htmlToSprite';
    export * from 'l3-graph/l3Graph/toolbar';
}

declare module 'l3-graph/l3Graph/l3Graph' {
    import * as React from 'react';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { ViewController, ViewControllersSet } from 'l3-graph/l3Graph/controllers/viewController';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { ViewOptions } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector2d, Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { WidgetFactory, Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    export interface L3GraphProps {
        viewOptions?: ViewOptions;
        viewControllers?: ViewControllersSet;
        onComponentMount?: (graph: L3Graph) => void;
        onComponentUnmount?: (graph: L3Graph) => void;
    }
    export class L3Graph extends React.Component<L3GraphProps> {
        a: GraphDescriptor;
        constructor(props: L3GraphProps);
        readonly model: DiagramModel<GraphDescriptor<unknown, unknown>>;
        resize(): void;
        getViewControllers(): ReadonlyArray<ViewController>;
        getViewController(): ViewController;
        setViewController(viewController: ViewController): void;
        attachOverlayToNode(node: Node, overlay: ReactOverlay<Node>, position: OverlayPosition): void;
        removeOverlayFromNode(node: Node, overlayId: string): void;
        componentDidMount(): void;
        componentWillUnmount(): void;
        clientPosTo3dPos(position: Vector2d, distanceFromScreen?: number): Vector3d;
        pos3dToClientPos(position: Vector3d): Vector2d;
        registerWidget<CustomWidget extends Widget>(widgetResolver: WidgetFactory<CustomWidget>): void;
        removeWidget(widgetId: string): void;
        render(): JSX.Element;
    }
}

declare module 'l3-graph/l3Graph/views/diagramView' {
    import * as React from 'react';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { TemplateProvider } from 'l3-graph/l3Graph/customization';
    import { GraphView } from 'l3-graph/l3Graph/views/graph/graphView';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { WidgetsView } from 'l3-graph/l3Graph/views/widgets/widgetsView';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { DragHandlerEvents } from 'l3-graph/l3Graph/input/dragHandler';
    import { Core } from 'l3-graph/l3Graph/core';
    export interface ViewOptions {
        nodeTemplateProvider?: TemplateProvider<Node>;
        linkTemplateProvider?: TemplateProvider<Link>;
    }
    export interface DiagramViewProps {
        model: DiagramModel;
        core: Core;
        onViewMount?: (view: DiagramView) => void;
        viewOptions?: ViewOptions;
        dragHandlers?: Subscribable<DragHandlerEvents>[];
    }
    export interface CameraState {
        position: Vector3d;
        focusDirection?: Vector3d;
    }
    export const DEFAULT_CAMERA_DIST = 100;
    export const DEFAULT_SCREEN_PARAMETERS: {
        VIEW_ANGLE: number;
        NEAR: number;
        FAR: number;
    };
    export class DiagramView extends React.Component<DiagramViewProps> {
        core: Core;
        graphView: GraphView;
        widgetsView: WidgetsView<any>;
        meshHtmlContainer: HTMLElement;
        overlayHtmlContainer: HTMLElement;
        constructor(props: DiagramViewProps);
        componentDidMount(): void;
        componentDidUpdate(): void;
        render(): JSX.Element;
    }
}

declare module 'l3-graph/l3Graph/models/graph/node' {
    import { Vector3d, Size } from 'l3-graph/l3Graph/models/structures';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { PointEvents, Point, PointParameters, PointId } from 'l3-graph/l3Graph/models/point';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export type NodeId = PointId & {
        nodePlaceholder?: boolean;
    };
    export interface NodeModel<NodeContent> {
        id: NodeId;
        data?: NodeContent;
    }
    export interface NodeParameters extends PointParameters {
        size?: Size;
    }
    export interface NodeEvents extends PointEvents {
        'change:size': Vector3d;
        'force-update': void;
    }
    export class Node<Descriptor extends GraphDescriptor = GraphDescriptor> extends Point<NodeEvents> {
        incomingLinks: Set<Link<Descriptor>>;
        outgoingLinks: Set<Link<Descriptor>>;
        modelIsChanged: boolean;
        readonly id: NodeId;
        constructor(_model: NodeModel<Descriptor['nodeContentType']>, parameters?: NodeParameters);
        readonly data: Descriptor["nodeContentType"];
        setData(data: Descriptor['nodeContentType']): void;
        readonly model: NodeModel<Descriptor['nodeContentType']>;
        readonly size: Size;
        setSize(size: Size): void;
        forceUpdate(): void;
    }
}

declare module 'l3-graph/l3Graph/models/graph/link' {
    import { Node, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export const DEFAULT_LINK_ID = "l3graph-link";
    export type LinkId = string & {
        linkPlaceholder?: boolean;
    };
    export interface LinkModel<LinkContent> {
        id: LinkId;
        sourceId: NodeId;
        targetId: NodeId;
        data?: LinkContent;
    }
    export interface LinkParameters<Descriptor extends GraphDescriptor> {
        source: Node<Descriptor>;
        target: Node<Descriptor>;
    }
    export interface LinkEvents {
        'force-update': void;
    }
    export class Link<Descriptor extends GraphDescriptor = GraphDescriptor> extends Subscribable<LinkEvents> {
        readonly model: LinkModel<Descriptor['linkContentType']>;
        readonly source: Node<Descriptor>;
        readonly target: Node<Descriptor>;
        modelIsChanged: boolean;
        constructor(model: LinkModel<Descriptor['linkContentType']>, parameters: LinkParameters<Descriptor>);
        readonly id: LinkId;
        readonly data: Descriptor["linkContentType"];
        setData(data: Descriptor['linkContentType']): void;
        forceUpdate(): void;
    }
}

declare module 'l3-graph/l3Graph/models/graph/graphDescriptor' {
    export interface DefaultNodeContent {
        label: string;
    }
    export interface DefaultLinkContent {
        label: string;
    }
    export interface GraphDescriptor<NodeContent = unknown, LinkContent = unknown> {
        nodeContentType: NodeContent;
        linkContentType: LinkContent;
    }
    export interface DefaultDescriptor {
        nodeContentType: DefaultNodeContent;
        linkContentType: DefaultLinkContent;
    }
}

declare module 'l3-graph/l3Graph/models/graph/graphModel' {
    import { Node, NodeModel, NodeParameters, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    import { Link, LinkModel, LinkId } from 'l3-graph/l3Graph/models/graph/link';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export type NodeDefinition<NodeContent = unknown> = NodeModel<NodeContent> & NodeParameters;
    export type Element<Descriptor extends GraphDescriptor = GraphDescriptor> = Node<Descriptor> | Link<Descriptor>;
    export type ElementModel<Descriptor extends GraphDescriptor = GraphDescriptor> = NodeModel<Descriptor['nodeContentType']> | LinkModel<Descriptor['linkContentType']>;
    export interface GraphModelEvents<Descriptor extends GraphDescriptor = GraphDescriptor> {
        'add:nodes': Node<Descriptor>[];
        'remove:nodes': Node<Descriptor>[];
        'update:nodes': Node<Descriptor>[];
        'add:links': Link<Descriptor>[];
        'remove:links': Link<Descriptor>[];
        'update:links': Link<Descriptor>[];
    }
    export interface ImmutableMap<K, V> {
        forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
        get(key: K): V | undefined;
        has(key: K): boolean;
        readonly size: number;
    }
    export interface ImmutableSet<T> {
        forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void;
        has(value: T): boolean;
        readonly size: number;
    }
    export class GraphModel<Descriptor extends GraphDescriptor = GraphDescriptor> extends Subscribable<GraphModelEvents<Descriptor>> {
        readonly nodes: ImmutableMap<NodeId, Node<Descriptor>>;
        readonly links: ImmutableMap<LinkId, Link<Descriptor>>;
        getNodeById(id: NodeId): Node<Descriptor>;
        getLinkById(id: LinkId): Link<Descriptor>;
        addNodes(nodes: NodeDefinition<Descriptor['nodeContentType']>[]): void;
        addLinks(models: LinkModel<Descriptor['linkContentType']>[]): void;
        updateNodes(definitions: NodeDefinition<Descriptor['nodeContentType']>[]): void;
        updateLinks(models: LinkModel<Descriptor['linkContentType']>[]): void;
        removeNodes(nodes: Node<Descriptor>[]): void;
        removeLinks(links: Link<Descriptor>[]): void;
    }
}

declare module 'l3-graph/l3Graph/customization' {
    export * from 'l3-graph/l3Graph/customization/defaultLinkTemplate';
    export * from 'l3-graph/l3Graph/customization/defaultNodeTemplate';
    export * from 'l3-graph/l3Graph/customization/defaultOverlay';
    export * from 'l3-graph/l3Graph/customization/mesh';
    export * from 'l3-graph/l3Graph/customization/templates';
}

declare module 'l3-graph/l3Graph/controllers/viewController' {
    import { Vector3 } from 'three';
    import { MouseHandler } from 'l3-graph/l3Graph/input/mouseHandler';
    import { KeyHandler } from 'l3-graph/l3Graph/input/keyHandler';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { GamepadHandler } from 'l3-graph/l3Graph/input/gamepadHandler';
    import { Core } from 'l3-graph/l3Graph/core';
    export const ROTATION_DECREASE_SPEED = 300;
    export const CAMERA_STEP_SPEED = 20;
    export const ZERO_POSITION: Vector3;
    export const ZOOM_STEP_MULTIPLAYER = 1;
    export const KEY_ROTATION_DECREASE_SPEED = 10;
    export const BORDER_OPACITY = 100;
    export interface ViewControllerEvents {
        'switched:off': void;
        'switched:on': void;
    }
    export interface ViewController extends Subscribable<ViewControllerEvents> {
        id: string;
        label: string;
        switchOn: () => void;
        switchOff: () => void;
        focusOn: (element: Element) => void;
    }
    export type ViewControllersSet = ((core: Core, mouseHandler: MouseHandler, keyHandler: KeyHandler, gamepadHandler: GamepadHandler) => ViewController)[];
}

declare module 'l3-graph/l3Graph/layout/layouts' {
    import * as cola from 'webcola';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { GraphModel } from 'l3-graph/l3Graph/models/graph/graphModel';
    export const PREFERRED_LINK_LENGTH = 75;
    export interface LayoutNode {
        id?: string;
        x: number;
        y: number;
        width: number;
        height: number;
        originalNode: Node;
        bounds?: any;
        innerBounds?: any;
    }
    export interface LayoutLink {
        originalLink: Link;
        source: LayoutNode;
        target: LayoutNode;
    }
    export class LayoutNode3D extends cola.Node3D {
        node: Node;
        constructor(node: Node);
    }
    export class LayoutLink3D extends cola.Link3D {
        link: Link;
        constructor(link: Link, sourceIndex: number, targetIndex: number);
    }
    export function forceLayout(params: {
        iterations: number;
        nodes: LayoutNode[];
        links: LayoutLink[];
        preferredLinkLength: number;
    }): void;
    export function forceLayout3d(params: {
        iterations: number;
        nodes: cola.Node3D[];
        links: cola.Link3D[];
        preferredLinkLength: number;
    }): void;
    export function flowLayout(params: {
        iterations: number;
        nodes: LayoutNode[];
        links: LayoutLink[];
        preferredLinkLength: number;
    }): void;
    export function applyForceLayout(graph: GraphModel): void;
    export function applyForceLayout3d(graph: GraphModel, iterations?: number, linkLength?: number): void;
}

declare module 'l3-graph/l3Graph/utils/subscribable' {
    export interface EventObject<Key, Events> {
        eventId: Key;
        data: Events;
    }
    export type EventCallback<Events, Key extends keyof Events> = (event: EventObject<Key, Events[Key]>) => void;
    export class Subscribable<Events> {
        on<Key extends keyof Events>(eventId: Key, callback: EventCallback<Events, Key>): void;
        onAny(callback: EventCallback<Events, keyof Events>): void;
        unsubscribe<Key extends keyof Events>(eventId: Key, callback: EventCallback<Events, Key>): void;
        unsubscribeFromAll(callback: EventCallback<Events, keyof Events>): void;
        trigger<Key extends keyof Events>(eventId: Key, eventObject?: Events[Key]): void;
    }
    export default Subscribable;
}

declare module 'l3-graph/l3Graph/utils/colorUtils' {
    export function rgbToHex(r: number, g: number, b: number): string;
    export function HSVtoRGB(h: number, s: number, v: number): {
        r: number;
        g: number;
        b: number;
    };
    export function hashFnv32a(str: string, seed?: number): number;
}

declare module 'l3-graph/l3Graph/models/widgets/widget' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { MouseHandler } from 'l3-graph/l3Graph/input/mouseHandler';
    import { KeyHandler } from 'l3-graph/l3Graph/input/keyHandler';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { GamepadHandler } from 'l3-graph/l3Graph/input/gamepadHandler';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    export const DEFAULT_SELECTION_TYPE_ID = "l3graph-selection";
    export type WidgetId = string & {
        widgetPlaceholder?: boolean;
    };
    export interface WidgetEvents {
        'update:widget': void;
    }
    export abstract class Widget<Events extends WidgetEvents = WidgetEvents> extends Subscribable<Events> {
        readonly widgetId: WidgetId;
        onRemove?(): void;
        forceUpdate: () => void;
    }
    export interface WidgetModelContext {
        diagramModel: DiagramModel;
        keyHandler: KeyHandler;
        mouseHandler: MouseHandler;
        gamepadHandler: GamepadHandler;
        vrManager: VrManager;
    }
    export interface WidgetViewContext<WidgetModel extends Widget> {
        diagramView: DiagramView;
        vrManager: VrManager;
        widget: WidgetModel;
    }
    export type WidgetModelResolver<WidgetModel extends Widget> = (context: WidgetModelContext) => WidgetModel;
    export type WidgetViewResolver<WidgetModel extends Widget> = (context: WidgetViewContext<WidgetModel>) => DiagramWidgetView;
    export interface WidgetFactory<WidgetModel extends Widget> {
        getModel: WidgetModelResolver<WidgetModel>;
        getView: WidgetViewResolver<WidgetModel>;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/gamepadsWidget' {
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GamepadHandler } from 'l3-graph/l3Graph/input/gamepadHandler';
    import { GamepadTool } from 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools';
    export interface GamepadsWidgetProps {
        gamepadHandler: GamepadHandler;
        leftTool?: GamepadTool;
        rightTool?: GamepadTool;
    }
    export class GamepadsWidget extends Widget {
        props: GamepadsWidgetProps;
        readonly widgetId: string;
        constructor(props: GamepadsWidgetProps);
        onRemove(): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadsWidgetView' {
    import * as THREE from 'three';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    export interface GamepadsWidgetViewParameters {
        model: GamepadsWidget;
        vrManager: VrManager;
    }
    export class GamepadsWidgetView implements DiagramWidgetView {
        readonly model: GamepadsWidget;
        readonly mesh: THREE.Group;
        constructor(parameters: GamepadsWidgetViewParameters);
        getBoundingBox(): THREE.Box3;
        update(): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools' {
    import * as THREE from 'three';
    import { GamepadHandler, GAMEPAD_BUTTON } from 'l3-graph/l3Graph/input/gamepadHandler';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    export interface GamepadToolProps {
        gamepadHandler: GamepadHandler;
        vrManager: VrManager;
    }
    export interface GamepadToolEvents {
        'update:gamepad': void;
    }
    export abstract class GamepadTool extends Subscribable<GamepadToolEvents> {
        mesh: THREE.Object3D;
        constructor();
        protected forceUpdate: () => void;
        abstract discard(): void;
    }
    export class LeftGamepadTool extends GamepadTool {
        protected props: GamepadToolProps;
        constructor(props: GamepadToolProps);
        protected readonly controller: THREE.Group;
        protected readonly COLOR: string;
        discard(): void;
    }
    export class RightGamepadTool extends LeftGamepadTool {
        constructor(props: GamepadToolProps);
        protected TARGET_BUTTON: GAMEPAD_BUTTON;
        protected readonly COLOR: string;
        protected readonly controller: THREE.Group;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/focusNodeWidget' {
    import { NodeWidget, NodeWidgetParameters } from 'l3-graph/l3Graph/models/widgets/nodeWidget';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    export interface FocusNodeWidgetParameters extends NodeWidgetParameters {
        diagramModel: DiagramModel;
    }
    export class FocusNodeWidget extends NodeWidget {
        constructor(parameters: FocusNodeWidgetParameters);
    }
}

declare module 'l3-graph/l3Graph/views/widgets/reactNodeWidgetView' {
    import * as THREE from 'three';
    import { FocusNodeWidget } from 'l3-graph/l3Graph/models/widgets/focusNodeWidget';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    export interface ReactNodeWidgetViewParameters {
        diagramView: DiagramView;
        model: FocusNodeWidget;
        overlay: ReactOverlay<Node>;
        position?: OverlayPosition;
    }
    export class ReactNodeWidgetView implements DiagramWidgetView {
        readonly model: FocusNodeWidget;
        readonly mesh: THREE.Group;
        constructor(parameters: ReactNodeWidgetViewParameters);
        getBoundingBox(): THREE.Box3;
        update(): void;
        onRemove(): void;
    }
}

declare module 'l3-graph/l3Graph/views/viewInterface' {
    import * as THREE from 'three';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { AbstractOverlayAnchor } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    export interface View<Model> {
        readonly mesh: THREE.Object3D | null;
        readonly overlayAnchor?: AbstractOverlayAnchor<Model, View<Model>>;
        getBoundingBox(): THREE.Box3;
        update(): void;
        onRemove?(): void;
        model: Model;
    }
    export type DiagramElementView = (View<Node> | View<Link>);
    export type DiagramWidgetView = View<Widget>;
}

declare module 'l3-graph/l3Graph/views/graph/overlayAnchor' {
    import * as THREE from 'three';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { Box, Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { CSS3DSprite } from 'l3-graph/l3Graph/utils/CSS3DRenderer';
    import { Rendered3dSprite } from 'l3-graph/l3Graph/utils/htmlToSprite';
    export type OverlayPosition = 'nw' | 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w' | 'c';
    export interface OverlayAnchorEvents {
        'anchor:changed': void;
    }
    export abstract class AbstractOverlayAnchor<Model = unknown, View = unknown> extends Subscribable<OverlayAnchorEvents> {
        protected meshModel: Model;
        protected meshView: View;
        readonly html: HTMLElement;
        readonly _renderedOverlays: Map<string, HTMLElement>;
        readonly _overlayPositions: Map<string, OverlayPosition>;
        readonly sprite: CSS3DSprite;
        protected overlaysByPosition: Map<OverlayPosition, Map<string, ReactOverlay<Model>>>;
        constructor(meshModel: Model, meshView: View);
        readonly overlays: ReadonlyMap<OverlayPosition, ReadonlyMap<string, ReactOverlay<Model>>>;
        hasOverlay(overlayId: string): boolean;
        isVisible(): boolean;
        hide(): void;
        setOverlay(overlay: ReactOverlay<Model>, position: OverlayPosition): void;
        removeOverlay(id: string): void;
        update(): void;
        protected enrichOverlay(poorOverlay: ReactOverlay<Model>): ReactOverlay<Model>;
        protected overlayedGroup: (props: any) => JSX.Element;
        abstract getModelFittingBox(): Box;
        abstract createAnchor3d(): AbstractOverlayAnchor3d<Model, View>;
    }
    export abstract class AbstractOverlayAnchor3d<Model = unknown, View = unknown> {
        protected meshModel: Model;
        protected meshView: View;
        protected overlayAnchor: AbstractOverlayAnchor<Model, View>;
        readonly mesh: THREE.Object3D;
        sprites: Rendered3dSprite[];
        constructor(meshModel: Model, meshView: View, overlayAnchor: AbstractOverlayAnchor<Model, View>);
        update(): void;
        abstract forceUpdate(): void;
        abstract updatePosition(): void;
        abstract placeSprites(sprites: Rendered3dSprite[]): void;
    }
    export function applyOffset(basicVector: Vector3d, offset: Vector3d, position: OverlayPosition): Vector3d;
}

declare module 'l3-graph/l3Graph/defaultWidgetsSet' {
    import { SelectionWidget } from 'l3-graph/l3Graph/models/widgets/selectionWidget';
    import { ArrowHelper } from 'l3-graph/l3Graph/models/widgets/arrowHelper';
    import { WidgetFactory } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    export const selectionWidgetFactory: WidgetFactory<SelectionWidget>;
    export const arrowHelperWidgetFactory: WidgetFactory<ArrowHelper>;
    export const gamepadsWidgetFactory: WidgetFactory<GamepadsWidget>;
    export function DEFAULT_MESH_WIDGET_SET(): WidgetFactory<any>[];
}

declare module 'l3-graph/l3Graph/input/gamepadHandler' {
    import * as THREE from 'three';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { DragHandlerEvents } from 'l3-graph/l3Graph/input/dragHandler';
    export type Controller = THREE.Group;
    export interface GamepadHandlerEvents extends DragHandlerEvents {
        'keyDown': {
            controller: Controller;
            button: GAMEPAD_BUTTON;
        };
        'keyUp': {
            controller: Controller;
            button: GAMEPAD_BUTTON;
        };
    }
    export const GAMEPAD_EXTRA_MOVE_STEP = 10;
    export enum GAMEPAD_BUTTON {
        TRIGGER = "TRIGGER",
        GRUBBER = "GRUBBER"
    }
    export const OCULUS_CONTROLLERS: {
        LEFT_CONTROLLER: number;
        RIGHT_CONTROLLER: number;
    };
    export const CONTROLLERS_NUMBER: number;
    export class GamepadHandler extends Subscribable<GamepadHandlerEvents> {
        constructor(diagramModel: DiagramModel, diagramView: DiagramView);
        getController(controllerId: number): THREE.Group;
        readonly keyPressedMap: ReadonlyMap<Controller, ReadonlySet<GAMEPAD_BUTTON>>;
    }
    export function attach(child: THREE.Object3D, to: THREE.Object3D, scene: THREE.Scene): void;
    export function detach(child: THREE.Object3D, parent: THREE.Object3D, scene: THREE.Scene): void;
    export function _attach(child: THREE.Object3D, scene: THREE.Scene, parent: THREE.Object3D): void;
}

declare module 'l3-graph/l3Graph/utils/htmlToSprite' {
    import * as THREE from 'three';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Vector2d } from 'l3-graph/l3Graph/models/structures';
    export interface Rendered3dSprite {
        sprite: THREE.Sprite;
        position: OverlayPosition;
        size: Vector2d;
    }
    export function createSprite(htmlOverlay: HTMLElement, position: OverlayPosition): Promise<Rendered3dSprite>;
    export function htmlToImage(htmlElement: HTMLElement): Promise<HTMLImageElement>;
}

declare module 'l3-graph/l3Graph/toolbar' {
    import * as React from 'react';
    import { ViewController } from 'l3-graph/l3Graph/controllers/viewController';
    export interface ToolbarProps {
        viewControllers: ReadonlyArray<ViewController>;
        selectedViewController?: ViewController;
        onChangeViewController: (viewController: ViewController) => void;
        onApplyLayout: () => void;
    }
    export class Toolbar extends React.Component<ToolbarProps> {
        constructor(props: ToolbarProps);
        componentDidMount(): void;
        setViewController(selectedViewController: ViewController): void;
        render(): JSX.Element;
    }
}

declare module 'l3-graph/l3Graph/models/diagramModel' {
    import { GraphModel, ImmutableMap } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Node, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    import { Link, LinkId } from 'l3-graph/l3Graph/models/graph/link';
    import { WidgetsModel } from 'l3-graph/l3Graph/models/widgets/widgetsModel';
    import { Selection } from 'l3-graph/l3Graph/models/widgets/selection';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface NodeEvent<Descriptor extends GraphDescriptor> {
        type: 'add:node' | 'remove:node' | 'update:node';
        target: Node<Descriptor>;
    }
    export interface LinkEvent<Descriptor extends GraphDescriptor> {
        type: 'add:link' | 'remove:link' | 'update:link';
        target: Link<Descriptor>;
    }
    export interface WidgetEvent {
        type: 'add:widget' | 'remove:widget' | 'update:widget';
        target: Widget;
    }
    export interface DiagramEvents<Descriptor extends GraphDescriptor> {
        nodeEvents: ReadonlyArray<NodeEvent<Descriptor>>;
        linkEvents: ReadonlyArray<LinkEvent<Descriptor>>;
        widgetEvents: ReadonlyArray<WidgetEvent>;
    }
    export interface DiagramModelEvents<Descriptor extends GraphDescriptor> {
        'syncupdate': DiagramEvents<Descriptor>;
    }
    export class DiagramModel<Descriptor extends GraphDescriptor = GraphDescriptor> extends Subscribable<DiagramModelEvents<Descriptor>> {
        graph: GraphModel<Descriptor>;
        widgetRegistry: WidgetsModel;
        selection: Selection;
        constructor();
        readonly nodes: ImmutableMap<NodeId, Node>;
        readonly links: ImmutableMap<LinkId, Link>;
        performSyncUpdate: () => void;
    }
}

declare module 'l3-graph/l3Graph/models/structures' {
    export interface Vector3d {
        x: number;
        y: number;
        z: number;
    }
    export interface Vector2d {
        x: number;
        y: number;
    }
    export type Size = Vector3d & {
        placeholder?: boolean;
    };
    export interface Rectangle extends Vector2d {
        width: number;
        height: number;
    }
    export interface Box extends Vector3d {
        width: number;
        height: number;
        deep: number;
    }
    export enum Object3dKind {
        Mesh = "mesh",
        Line = "line"
    }
    export type Polygon3d = [Vector3d, Vector3d, Vector3d];
    export interface Mesh {
        type: Object3dKind.Mesh;
        polygons: Polygon3d[];
    }
    export interface Line {
        type: Object3dKind.Line;
        points: Vector3d[];
    }
}

declare module 'l3-graph/l3Graph/views/graph/graphView' {
    import { GraphModel, Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { NodeView } from 'l3-graph/l3Graph/views/graph/nodeView';
    import { LinkView } from 'l3-graph/l3Graph/views/graph/linkView';
    import { TemplateProvider } from 'l3-graph/l3Graph/customization';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { Link, LinkId } from 'l3-graph/l3Graph/models/graph/link';
    import { Node, NodeId } from 'l3-graph/l3Graph/models/graph/node';
    import { LinkRouter } from 'l3-graph/l3Graph/utils/linkRouter';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { Core } from 'l3-graph/l3Graph/core';
    import { AbstractOverlayAnchor, AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    export interface GraphViewProps {
        core: Core;
        graphModel: GraphModel;
        vrManager: VrManager;
        nodeTemplateProvider?: TemplateProvider<Node>;
        linkTemplateProvider?: TemplateProvider<Link>;
        simpleLinks?: boolean;
    }
    export interface GraphViewEvents {
        'overlay:down': {
            event: MouseEvent | TouchEvent;
            target: Element;
        };
    }
    export class GraphView extends Subscribable<GraphViewEvents> {
        nodeViews: Map<Node<GraphDescriptor<unknown, unknown>>, NodeView>;
        linkViews: Map<Link<GraphDescriptor<unknown, unknown>>, LinkView>;
        anchors3d: Map<AbstractOverlayAnchor<unknown, unknown>, AbstractOverlayAnchor3d<unknown, unknown>>;
        graphModel: GraphModel;
        meshHtmlContainer: HTMLElement;
        overlayHtmlContainer: HTMLElement;
        linkRouter: LinkRouter;
        constructor(props: GraphViewProps);
        registerNode(node: Node): NodeView;
        registerLink(link: Link): LinkView;
        removeNodeView(node: Node): void;
        removeLinkView(link: Link): void;
        update({ updatedNodeIds, updatedLinkIds, }: {
            updatedNodeIds: NodeId[];
            updatedLinkIds: LinkId[];
        }): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/widgetsView' {
    import { WidgetsModel } from 'l3-graph/l3Graph/models/widgets/widgetsModel';
    import { WidgetViewResolver, Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { Core } from 'l3-graph/l3Graph/core';
    export interface WidgetsViewProps {
        diagramView: DiagramView;
        vrManager: VrManager;
        widgetsModel: WidgetsModel;
        core: Core;
    }
    export class WidgetsView<CustomWidget extends Widget> {
        diagramView: DiagramView;
        vrManager: VrManager;
        widgetsModel: WidgetsModel;
        constructor(props: WidgetsViewProps);
        registerViewResolver(widgetId: string, viewResolver: WidgetViewResolver<CustomWidget>): void;
        registerWidgetViewForModel(widget: CustomWidget): void;
        removeWidgetViewOfModel(widget: Widget): void;
        update(specificIds?: string[]): void;
    }
}

declare module 'l3-graph/l3Graph/utils' {
    export * from 'l3-graph/l3Graph/utils/colorUtils';
    export * from 'l3-graph/l3Graph/utils/shapeUtils';
    export * from 'l3-graph/l3Graph/utils/subscribable';
    export * from 'l3-graph/l3Graph/utils/geometry';
    export function generate128BitID(): string;
}

declare module 'l3-graph/l3Graph/input/dragHandler' {
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    export interface DragEventData {
        target: Element;
        position: Vector3d;
    }
    export interface DragHandlerEvents {
        'elementHoverStart': DragEventData;
        'elementHover': DragEventData;
        'elementHoverEnd': DragEventData;
        'elementDragStart': DragEventData;
        'elementDrag': DragEventData;
        'elementDragEnd': DragEventData;
    }
}

declare module 'l3-graph/l3Graph/core' {
    import * as THREE from 'three';
    import { CSS3DRenderer } from 'l3-graph/l3Graph/utils/CSS3DRenderer';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { Vector3d, Vector2d } from 'l3-graph/l3Graph/models/structures';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    export const DEFAULT_CAMERA_DIST = 100;
    export const DEFAULT_SCREEN_PARAMETERS: {
        VIEW_ANGLE: number;
        NEAR: number;
        FAR: number;
    };
    export interface CameraState {
        position: Vector3d;
        focusDirection?: Vector3d;
    }
    export type AnimationLoopAction = () => boolean;
    export interface CancellationEvents {
        'cancel': void;
    }
    export class Cancellation extends Subscribable<CancellationEvents> {
        isCancelled: boolean;
        stop(): void;
    }
    export class Core {
        renderer: THREE.WebGLRenderer;
        overlayRenderer: CSS3DRenderer;
        camera: THREE.PerspectiveCamera;
        scene: THREE.Scene;
        rootHTML: HTMLElement | undefined;
        rootOverlayHtml: HTMLElement | undefined;
        vrManager: VrManager;
        screenParameters: {
            WIDTH: number;
            HEIGHT: number;
            VIEW_ANGLE: number;
            ASPECT: number;
            NEAR: number;
            FAR: number;
        };
        constructor();
        addAnimationLoopAction(action: AnimationLoopAction): void;
        removeAnimationLoopAction(action: AnimationLoopAction): void;
        animationFrameInterval(intervalCallback: () => boolean | void): Cancellation;
        attachTo(rootHTML: HTMLElement, rootOverlayHtml: HTMLElement): void;
        mouseTo3dPos(event: MouseEvent | TouchEvent, distanceFromScreen?: number): Vector3d;
        clientPosTo3dPos(position: Vector2d, distanceFromScreen?: number): Vector3d;
        pos3dToClientPos(position: Vector3d): Vector2d;
        readonly cameraState: CameraState;
        setCameraState(cameraState: CameraState): void;
        resize(): void;
        forceRender: (callback?: () => void) => void;
    }
}

declare module 'l3-graph/l3Graph/models/point' {
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    export type PointId = string & {
        pointPlaceholder?: boolean;
    };
    export interface PointParameters {
        position: Vector3d;
    }
    export interface PointEvents {
        'change:position': Vector3d;
    }
    export abstract class Point<Events extends PointEvents = PointEvents> extends Subscribable<Events> {
        readonly id: PointId;
        protected _position: Vector3d;
        constructor(parameters: PointParameters);
        readonly position: Vector3d;
        setPosition(position: Vector3d): void;
    }
}

declare module 'l3-graph/l3Graph/customization/defaultLinkTemplate' {
    import { DefaultDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { LinkViewTemplate, TemplateProvider } from 'l3-graph/l3Graph/customization/templates';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    export const DEFAULT_LINK_TEMPLATE: LinkViewTemplate<DefaultDescriptor>;
    export const DEFAULT_LINK_TEMPLATE_PROVIDER: TemplateProvider<Link<DefaultDescriptor>, DefaultDescriptor>;
}

declare module 'l3-graph/l3Graph/customization/defaultNodeTemplate' {
    import { ViewTemplate, TemplateProvider } from 'l3-graph/l3Graph/customization/templates';
    import { DefaultDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    export const DEFAULT_NODE_TEMPLATE: ViewTemplate<Node<DefaultDescriptor>>;
    export const DEFAULT_NODE_TEMPLATE_PROVIDER: TemplateProvider<Node<DefaultDescriptor>>;
}

declare module 'l3-graph/l3Graph/customization/defaultOverlay' {
    import * as React from 'react';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization/templates';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { DefaultDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    export const DEFAULT_NODE_OVERLAY: ReactOverlay<Node<DefaultDescriptor>>;
    export const DEFAULT_LINK_OVERLAY: ReactOverlay<Link<DefaultDescriptor>>;
    export function createContextProvider(context: any): React.ComponentClass;
    export function enrichOverlay<Model>(poorOverlay: ReactOverlay<Model>, data: Model): ReactOverlay<Model>;
}

declare module 'l3-graph/l3Graph/customization/mesh' {
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    export enum MeshKind {
        Obj = "obj",
        Primitive = "primitive",
        ThreeNative = "three-native"
    }
    export namespace THREE {
        type Object3D = any;
    }
    export interface Mesh {
        color?: string | number;
        texture?: string;
        preserveRatio?: boolean;
        size?: Vector3d;
    }
    export interface MeshNative extends Mesh {
        type: MeshKind.ThreeNative;
        mesh: THREE.Object3D;
    }
    export interface MeshObj extends Mesh {
        type: MeshKind.Obj;
        markup: string;
    }
    export interface MeshPrimitive extends Mesh {
        type: MeshKind.Primitive;
        shape: 'cube' | 'sphere' | 'cone' | 'cylinder' | 'dodecahedron' | 'torus' | 'tetrahedron' | 'plane';
    }
    export type L3Mesh = MeshNative | MeshObj | MeshPrimitive;
}

declare module 'l3-graph/l3Graph/customization/templates' {
    import * as React from 'react';
    import { L3Mesh } from 'l3-graph/l3Graph/customization/mesh';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    export interface OverlayProps<Model> {
        target?: Model;
    }
    export type NodeOverlayProps<Descriptor extends GraphDescriptor> = OverlayProps<Node<Descriptor>>;
    export type LinkOverlayProps<Descriptor extends GraphDescriptor> = OverlayProps<Link<Descriptor>>;
    export interface ReactOverlay<Model> {
        id: string;
        value: React.ReactElement<OverlayProps<Model>>;
        context?: any;
    }
    export interface ViewTemplate<Model> {
        overlay?: ReactOverlay<Model>;
        mesh?: () => L3Mesh;
    }
    export interface LinkViewTemplate<Descriptor extends GraphDescriptor = GraphDescriptor> {
        color: number | string;
        thickness?: number;
        overlay?: ReactOverlay<Link<Descriptor>>;
    }
    export type ProviderTemplateType<Model, Descriptor extends GraphDescriptor = GraphDescriptor> = Model extends Link<Descriptor> ? LinkViewTemplate<Descriptor> : ViewTemplate<Model>;
    export type TemplateProvider<Model, Descriptor extends GraphDescriptor = GraphDescriptor> = (model: Model) => ProviderTemplateType<Model, Descriptor>;
}

declare module 'l3-graph/l3Graph/input/mouseHandler' {
    import * as THREE from 'three';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector2d } from 'l3-graph/l3Graph/models/structures';
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { DragHandlerEvents } from 'l3-graph/l3Graph/input/dragHandler';
    export interface HandlerElementClickEvent {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        element: Element;
    }
    export interface HandlerDragElementEvent {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        element: Element;
    }
    export interface HandlerDragEvent {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        offset: Vector2d;
    }
    export interface MouseHandlerEvents extends DragHandlerEvents {
        'paperScroll': MouseWheelEvent;
        'elementClick': HandlerElementClickEvent;
        'paperClick': MouseEvent | TouchEvent;
        'paperStartDrag': HandlerDragEvent;
        'paperDrag': HandlerDragEvent;
        'paperEndDrag': HandlerDragEvent;
    }
    export class MouseHandler extends Subscribable<MouseHandlerEvents> {
        constructor(diagramModel: DiagramModel, diagramView: DiagramView);
        readonly isPanning: boolean;
        readonly isDragging: boolean;
        readonly draggedElement: Element | undefined;
        onMouseMoveEvent(event: MouseEvent): void;
        onMouseDownEvent(event: MouseEvent | TouchEvent, element?: Element): void;
        onScrollEvent(event: MouseWheelEvent, element?: Element): void;
    }
    export function mapMeshes(diagramModel: DiagramModel, diagramView: DiagramView): {
        meshes: THREE.Object3D[];
        nodeMeshMap: Element<GraphDescriptor<unknown, unknown>>[];
    };
    export function handleDragging(downEvent: MouseEvent | TouchEvent, onChange: (event: MouseEvent | TouchEvent, change: Vector2d) => void, onEnd?: (event: MouseEvent | TouchEvent, change?: Vector2d) => void): void;
}

declare module 'l3-graph/l3Graph/input/keyHandler' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Core } from 'l3-graph/l3Graph/core';
    export interface KeyHandlerEvents {
        'keyDown': Set<number>;
        'keyPressed': Set<number>;
        'keyUp': Set<number>;
    }
    export const KEY_CODES: {
        UP: number;
        DOWN: number;
        LEFT: number;
        RIGHT: number;
        SPACE: number;
        CTRL: number;
        PLUS: number;
        MINUS: number;
        DELETE: number;
        ESCAPE: number;
    };
    export class KeyHandler extends Subscribable<KeyHandlerEvents> {
        constructor(core: Core);
        switchOn(): void;
        switchOff(): void;
    }
}

declare module 'l3-graph/l3Graph/vrUtils/vrManager' {
    import Subscribable from 'l3-graph/l3Graph/utils/subscribable';
    import { Core } from 'l3-graph/l3Graph/core';
    export interface VrManagerEvents {
        'connection:state:changed': void;
    }
    export class VrManager extends Subscribable<VrManagerEvents> {
        constructor(core: Core);
        readonly camera: import("three").Camera;
        readonly isConnected: boolean;
        disconnect(): void;
        connect(): Promise<unknown>;
        getController(id: number): import("three").Group;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/nodeWidget' {
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { WidgetEvents, Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    export interface NodeWidgetEvents extends WidgetEvents {
        'change:focus': Node;
    }
    export interface NodeWidgetParameters {
        widgetId: string;
    }
    export abstract class NodeWidget extends Widget {
        readonly widgetId: string;
        constructor(parameters: NodeWidgetParameters);
        setFocusNode(target: Node | undefined): void;
        readonly isFocusNodeChanged: boolean;
        readonly focusNode: Node;
        readonly prevFocusNode: Node;
        onRemove(): void;
    }
}

declare module 'l3-graph/l3Graph/utils/CSS3DRenderer' {
    import * as THREE from 'three';
    export class CSS3DObject extends THREE.Object3D {
        element: HTMLElement;
        constructor(element: HTMLElement);
    }
    export class CSS3DSprite extends CSS3DObject {
        element: HTMLElement;
        constructor(element: HTMLElement);
    }
    export class CSS3DRenderer {
        _width: number;
        _height: number;
        _widthHalf: number;
        _heightHalf: number;
        matrix: THREE.Matrix4;
        cache: {
            camera: {
                fov: number;
                style: string;
            };
            objects: WeakMap<object, any>;
        };
        domElement: HTMLDivElement;
        cameraElement: HTMLDivElement;
        isIE: boolean;
        constructor();
        getSize(): {
            width: number;
            height: number;
        };
        setSize(width: number, height: number): void;
        render(scene: THREE.Scene, camera: THREE.Camera): void;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/selectionWidget' {
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export interface SelectionParameters {
        diagramModel: DiagramModel;
    }
    export class SelectionWidget extends Widget {
        readonly widgetId: string;
        constructor(parameters: SelectionParameters);
        readonly selectedElements: Element<GraphDescriptor<unknown, unknown>>[];
    }
}

declare module 'l3-graph/l3Graph/models/widgets/arrowHelper' {
    import { NodeWidget } from 'l3-graph/l3Graph/models/widgets/nodeWidget';
    import { MouseHandler } from 'l3-graph/l3Graph/input/mouseHandler';
    export interface ArrowHelperParameters {
        mouseHandler: MouseHandler;
    }
    export class ArrowHelper extends NodeWidget {
        constructor(parameters: ArrowHelperParameters);
        readonly isVisible: boolean;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/widgetsModel' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    export interface WidgetsModelEvents {
        'add:widget': Widget;
        'remove:widget': Widget;
        'update:widget': Widget;
    }
    export class WidgetsModel extends Subscribable<WidgetsModelEvents> {
        readonly widgets: ReadonlyMap<string, Widget>;
        registerWidget(widget: Widget): void;
        removeWidget(widget: Widget): void;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/selection' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { GraphModel } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    export interface SelectionParameters {
        selection?: Set<Node>;
        graph: GraphModel;
    }
    export interface SelectionEvents {
        'change': ReadonlySet<Node>;
    }
    export class Selection extends Subscribable<SelectionEvents> {
        readonly widgetId: string;
        constructor(parameters: SelectionParameters);
        setSelection(nodes: ReadonlySet<Node>): void;
        readonly elements: ReadonlySet<Node>;
    }
}

declare module 'l3-graph/l3Graph/views/graph/nodeView' {
    import * as THREE from 'three';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { ViewTemplate, ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { AbstractOverlayAnchor, AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { View } from 'l3-graph/l3Graph/views/viewInterface';
    import { Rendered3dSprite } from 'l3-graph/l3Graph/utils/htmlToSprite';
    import { GraphDescriptor } from 'l3-graph/l3Graph/models/graph/graphDescriptor';
    export class NodeView implements View<Node> {
        readonly model: Node;
        readonly mesh: THREE.Object3D;
        readonly overlayAnchor: NodeOverlayAnchor;
        constructor(model: Node, template: ViewTemplate<Node>);
        getBoundingBox(): THREE.Box3;
        update(): void;
    }
    export class NodeOverlayAnchor extends AbstractOverlayAnchor<Node, NodeView> {
        getModelFittingBox(): {
            width: number;
            height: number;
            deep: number;
            x: number;
            y: number;
            z: number;
        };
        protected enrichOverlay(poorOverlay: ReactOverlay<Node>): ReactOverlay<Node<GraphDescriptor<unknown, unknown>>>;
        createAnchor3d(): NodeOverlayAnchor3d;
    }
    export class NodeOverlayAnchor3d extends AbstractOverlayAnchor3d<Node, NodeView> {
        forceUpdate(): void;
        updatePosition(): void;
        placeSprites(renderedSprites: Rendered3dSprite[]): void;
    }
}

declare module 'l3-graph/l3Graph/views/graph/linkView' {
    import * as THREE from 'three';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { LinkViewTemplate } from 'l3-graph/l3Graph/customization';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { AbstractOverlayAnchor, AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { LinkRouter } from 'l3-graph/l3Graph/utils/linkRouter';
    import { View } from 'l3-graph/l3Graph/views/viewInterface';
    import { Rendered3dSprite } from 'l3-graph/l3Graph/utils/htmlToSprite';
    export class LinkView implements View<Link> {
        readonly model: Link;
        readonly router: LinkRouter;
        readonly mesh: THREE.Group;
        readonly overlayAnchor: LinkOverlayAnchor;
        polyline: Vector3d[];
        constructor(model: Link, router: LinkRouter, template: LinkViewTemplate);
        getBoundingBox(): THREE.Box3;
        update(): void;
    }
    export class LinkOverlayAnchor extends AbstractOverlayAnchor<Link, LinkView> {
        getModelFittingBox(): {
            x: number;
            y: number;
            z: number;
            width: number;
            height: number;
            deep: number;
        };
        protected overlayedGroup: (props: any) => JSX.Element;
        createAnchor3d(): LinkOverlayAnchor3d;
    }
    export class LinkOverlayAnchor3d extends AbstractOverlayAnchor3d<Link, LinkView> {
        forceUpdate(): void;
        updatePosition(): void;
        placeSprites(renderedSprites: Rendered3dSprite[]): void;
    }
}

declare module 'l3-graph/l3Graph/utils/linkRouter' {
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    export interface LinkRouter {
        getRout(link: Link): Vector3d[];
    }
    export class DefaultLinkRouter implements LinkRouter {
        getRout(link: Link): Vector3d[];
    }
    export function getPointAlongPolylineByRatio(polyline: ReadonlyArray<Vector3d>, ratio: number): Vector3d;
    export function getPointAlongPolyline(polyline: ReadonlyArray<Vector3d>, offset: number): Vector3d;
    export function computePolylineLength(polyline: ReadonlyArray<Vector3d>): number;
}

declare module 'l3-graph/l3Graph/utils/shapeUtils' {
    import * as THREE from 'three';
    import { MeshPrimitive, MeshObj } from 'l3-graph/l3Graph/customization';
    export function preparePrimitive(primitive: MeshPrimitive): THREE.Mesh;
    export function prepareMesh(meshObj: MeshObj): THREE.Object3D;
    export function setColor(mesh: THREE.Object3D, providedColor: string | number | Map<THREE.Object3D, string | number>): void;
    export function setMaterial(mesh: THREE.Object3D, material: THREE.Material): void;
    export function backupColors(mesh: THREE.Object3D): Map<THREE.Object3D, THREE.Material | THREE.Material[]>;
    export function restoreColors(mesh: THREE.Object3D, backUp: Map<THREE.Object3D, THREE.Material | THREE.Material[]>): void;
}

declare module 'l3-graph/l3Graph/utils/geometry' {
    import * as THREE from 'three';
    import { Vector3d, Vector2d, Size } from 'l3-graph/l3Graph/models/structures';
    export function vector3dToTreeVector3(v: Vector3d): THREE.Vector3;
    export function threeVector3ToVector3d(v: THREE.Vector3): Vector3d;
    export function calcBounds(points: Vector3d[]): {
        min: Vector3d;
        max: Vector3d;
        average: Vector3d;
    };
    export function normalize(vector: Vector3d): Vector3d;
    export function length(from: Vector3d | Vector2d): number;
    export function vectorLength({ x, y, z }: Vector3d): number;
    export function distance(from: Vector3d | Vector2d, to: Vector3d | Vector2d): number;
    export function inverse(vector: Vector3d): Vector3d;
    export function multiply(vector: Vector3d, k: number): Vector3d;
    export function sum(vector1: Vector3d, vector2: Vector3d): Vector3d;
    export function sumScalar(vector1: Vector3d, scalar: number): Vector3d;
    export function sub(vector1: Vector3d, vector2: Vector3d): Vector3d;
    export function normalLeft(vector: Vector3d): {
        x: number;
        y: number;
        z: number;
    };
    export function normalUp(vector: Vector3d): Vector3d;
    export function normalDown(vector: Vector3d): Vector3d;
    export function normalRight(vector: Vector3d): Vector3d;
    export function eventToPosition(event: MouseEvent | TouchEvent, viewBox?: ClientRect | DOMRect): Vector2d | undefined;
    export function getModelFittingBox({ x, y, z }: Size): {
        width: number;
        height: number;
        deep: number;
    };
}

