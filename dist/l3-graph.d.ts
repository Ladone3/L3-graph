// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../../react
//   ../../../three
//   ../../../webcola

declare module 'l3-graph' {
    export { L3Graph, L3GraphProps } from 'l3-graph/l3Graph/l3Graph';
    export { ViewOptions } from 'l3-graph/l3Graph/views/diagramView';
    export { Node, NodeModel } from 'l3-graph/l3Graph/models/graph/node';
    export { Link, LinkModel } from 'l3-graph/l3Graph/models/graph/link';
    export { NodeDefinition, Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    export { NodeViewTemplate, LinkViewTemplate, MeshKind, L3Mesh, MeshObj, MeshPrimitive, THREE, DEFAULT_NODE_TEMPLATE, DEFAULT_NODE_TEMPLATE_PROVIDER, DEFAULT_LINK_TEMPLATE, DEFAULT_LINK_TEMPLATE_PROVIDER, NodeTemplateProvider, LinkTemplateProvider, } from 'l3-graph/l3Graph/customization';
    export { ViewController } from 'l3-graph/l3Graph/controllers/viewController';
    export { applyForceLayout3d } from 'l3-graph/l3Graph/layout/layouts';
    export * from 'l3-graph/l3Graph/utils/subscribable';
    export * from 'l3-graph/l3Graph/utils/colorUtils';
    export { Widget as MeshWidget, WidgetModelContext, WidgetViewContext, } from 'l3-graph/l3Graph/models/widgets/widget';
    export { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    export { GamepadsWidgetView } from 'l3-graph/l3Graph/views/widgets/gamepadsWidgetView';
    export * from 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools';
    export * from 'l3-graph/l3Graph/views/widgets/gamepadTools/editorTools';
    export { FocusNodeWidget } from 'l3-graph/l3Graph/models/widgets/focusNodeWidget';
    export { ReactNodeWidgetView } from 'l3-graph/l3Graph/views/widgets/reactNodeWidgetView';
    export { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    export { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    export * from 'l3-graph/l3Graph/defaultWidgetsSet';
    export { GAMEPAD_BUTTON } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    export { htmlToImage } from 'l3-graph/l3Graph/utils/htmlToSprite';
}

declare module 'l3-graph/l3Graph/l3Graph' {
    import * as React from 'react';
    import { ViewController, ViewControllersSet } from 'l3-graph/l3Graph/controllers/viewController';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { ViewOptions } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector2d, Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { WidgetFactory } from 'l3-graph/l3Graph/models/widgets/widget';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    export interface L3GraphProps {
        viewOptions?: ViewOptions;
        viewControllers?: ViewControllersSet;
        onComponentMount?: (graph: L3Graph) => void;
        onComponentUnmount?: (graph: L3Graph) => void;
    }
    export class L3Graph extends React.Component<L3GraphProps> {
        constructor(props: L3GraphProps);
        readonly model: DiagramModel;
        resize(): void;
        setViewController(viewController: ViewController): void;
        attachOverlayToNode(node: Node, overlay: ReactOverlay, position: OverlayPosition): void;
        removeOverlayFromNode(node: Node, overlayId: string): void;
        componentDidMount(): void;
        componentWillUnmount(): void;
        clientPosTo3dPos(position: Vector2d, distanceFromScreen?: number): Vector3d;
        pos3dToClientPos(position: Vector3d): Vector2d;
        registerWidget(widgetResolver: WidgetFactory): void;
        removeWidget(widgetId: string): void;
        render(): JSX.Element;
    }
}

declare module 'l3-graph/l3Graph/views/diagramView' {
    import * as React from 'react';
    import * as THREE from 'three';
    import { Vector3d, Vector2d } from 'l3-graph/l3Graph/models/structures';
    import { NodeTemplateProvider, LinkTemplateProvider } from 'l3-graph/l3Graph/customization';
    import { GraphView } from 'l3-graph/l3Graph/views/graph/graphView';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { WidgetsView } from 'l3-graph/l3Graph/views/widgets/widgetsView';
    import { WebGLRenderer } from 'l3-graph/l3Graph/vrUtils/webVr';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { CSS3DRenderer } from 'l3-graph/l3Graph/utils/CSS3DRenderer';
    export interface ViewOptions {
        nodeTemplateProvider?: NodeTemplateProvider;
        linkTemplateProvider?: LinkTemplateProvider;
    }
    export interface DiagramViewProps {
        model: DiagramModel;
        onViewMount?: (view: DiagramView) => void;
        viewOptions?: ViewOptions;
    }
    export interface CameraState {
        position: Vector3d;
        focusDirection?: Vector3d;
    }
    export const DEFAULT_CAMERA_DIST = 100;
    export const DEFAULT_SCREEN_PARAMETERS: {
        VIEW_ANGLE: number;
        NEAR: number;
        FAR: number;
    };
    export class DiagramView extends React.Component<DiagramViewProps> {
        renderer: WebGLRenderer;
        overlayRenderer: CSS3DRenderer;
        graphView: GraphView;
        widgetsView: WidgetsView;
        camera: THREE.PerspectiveCamera;
        scene: THREE.Scene;
        meshHtmlContainer: HTMLElement;
        overlayHtmlContainer: HTMLElement;
        vrManager: VrManager;
        screenParameters: {
            WIDTH: number;
            HEIGHT: number;
            VIEW_ANGLE: number;
            ASPECT: number;
            NEAR: number;
            FAR: number;
        };
        constructor(props: DiagramViewProps);
        componentDidMount(): void;
        mouseTo3dPos(event: MouseEvent | TouchEvent, distanceFromScreen?: number): Vector3d;
        clientPosTo3dPos(position: Vector2d, distanceFromScreen?: number): Vector3d;
        pos3dToClientPos(position: Vector3d): Vector2d;
        cameraState: CameraState;
        resize(): void;
        renderGraph(): void;
        render(): JSX.Element;
    }
}

declare module 'l3-graph/l3Graph/models/graph/node' {
    import { Vector3d, Size } from 'l3-graph/l3Graph/models/structures';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { PointEvents, Point, PointParameters } from 'l3-graph/l3Graph/models/point';
    export interface NodeModel<NodeContent = any> {
        id: string;
        data?: NodeContent;
    }
    export interface NodeParameters extends PointParameters {
        size?: Size;
    }
    export interface NodeEvents extends PointEvents {
        'change:size': Vector3d;
        'force-update': void;
    }
    export class Node<NodeContent = any> extends Point<NodeEvents> {
        incomingLinks: Set<Link>;
        outgoingLinks: Set<Link>;
        modelIsChanged: boolean;
        readonly id: string;
        constructor(_model: NodeModel<NodeContent>, parameters?: NodeParameters);
        readonly data: NodeContent;
        setData(data: NodeContent): void;
        readonly model: NodeModel<NodeContent>;
        readonly size: Size;
        setSize(size: Size): void;
        forceUpdate(): void;
    }
}

declare module 'l3-graph/l3Graph/models/graph/link' {
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    export const DEFAULT_LINK_ID = "l3graph-link";
    export interface LinkModel<LinkContent = any> {
        id: string;
        sourceId: string;
        targetId: string;
        data?: LinkContent;
    }
    export interface LinkParameters {
        source: Node;
        target: Node;
    }
    export interface LinkEvents {
        'force-update': void;
    }
    export class Link<LinkContent = any> extends Subscribable<LinkEvents> {
        readonly model: LinkModel;
        readonly source: Node;
        readonly target: Node;
        modelIsChanged: boolean;
        constructor(model: LinkModel, parameters: LinkParameters);
        readonly id: string;
        readonly data: any;
        setData(data: LinkContent): void;
        forceUpdate(): void;
    }
}

declare module 'l3-graph/l3Graph/models/graph/graphModel' {
    import { Node, NodeModel, NodeParameters } from 'l3-graph/l3Graph/models/graph/node';
    import { Link, LinkModel } from 'l3-graph/l3Graph/models/graph/link';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    export type NodeDefinition<Contetnt = any> = NodeModel<Contetnt> & NodeParameters;
    export type Element = Node | Link;
    export type ElementModel = NodeModel | LinkModel;
    export interface GraphModelEvents {
        'add:elements': Element[];
        'remove:elements': Element[];
        'update:element': Element;
    }
    export interface ImmutableMap<K, V> {
        forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
        get(key: K): V | undefined;
        has(key: K): boolean;
        readonly size: number;
    }
    export interface ImmutableSet<T> {
        forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void;
        has(value: T): boolean;
        readonly size: number;
    }
    export class GraphModel extends Subscribable<GraphModelEvents> {
        readonly nodes: ImmutableMap<string, Node>;
        readonly links: ImmutableMap<string, Link>;
        getNodeById(id: string): Node<any>;
        getLinkById(id: string): Link<any>;
        addNodes(nodes: NodeDefinition[]): void;
        addLinks(models: LinkModel[]): void;
        updateNodes(definitions: NodeDefinition[]): void;
        updateLinks(models: LinkModel[]): void;
        removeNodes(nodes: Node[]): void;
        removeLinks(links: Link[]): void;
    }
}

declare module 'l3-graph/l3Graph/customization' {
    export * from 'l3-graph/l3Graph/customization/defaultLinkTemplate';
    export * from 'l3-graph/l3Graph/customization/defaultNodeTemplate';
    export * from 'l3-graph/l3Graph/customization/defaultOverlay';
    export * from 'l3-graph/l3Graph/customization/mesh';
    export * from 'l3-graph/l3Graph/customization/templates';
}

declare module 'l3-graph/l3Graph/controllers/viewController' {
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector3 } from 'three';
    import { MouseHandler } from 'l3-graph/l3Graph/utils/mouseHandler';
    import { KeyHandler, Subscribable } from 'l3-graph/l3Graph/utils';
    import { GamepadHandler } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    export const ROTATION_DECREASE_SPEED = 300;
    export const CAMERA_STEP_SPEED = 20;
    export const ZERO_POSITION: Vector3;
    export const ZOOM_STEP_MULTIPLAYER = 1;
    export const KEY_ROTATION_DECREASE_SPEED = 10;
    export const BORDER_OPACITY = 100;
    export interface ViewControllerEvents {
        'switched:off': void;
        'switched:on': void;
    }
    export interface ViewController extends Subscribable<ViewControllerEvents> {
        id: string;
        label: string;
        switchOn: () => void;
        switchOff: () => void;
        focusOn: (element: Element) => void;
    }
    export type ViewControllersSet = ((view: DiagramView, mouseHandler: MouseHandler, keyHandler: KeyHandler, gamepadHandler: GamepadHandler) => ViewController)[];
}

declare module 'l3-graph/l3Graph/layout/layouts' {
    import * as cola from 'webcola';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { GraphModel } from 'l3-graph/l3Graph/models/graph/graphModel';
    export const PREFFERED_LINK_LENGTH = 75;
    export interface LayoutNode {
        id?: string;
        x: number;
        y: number;
        width: number;
        height: number;
        originalNode: Node;
        bounds?: any;
        innerBounds?: any;
    }
    export interface LayoutLink {
        originalLink: Link;
        source: LayoutNode;
        target: LayoutNode;
    }
    export class LayoutNode3D extends cola.Node3D {
        node: Node;
        constructor(node: Node);
    }
    export class LayoutLink3D extends cola.Link3D {
        link: Link;
        constructor(link: Link, sourceIndex: number, targetIndex: number);
    }
    export interface LayoutLink {
        originalLink: Link;
        source: LayoutNode;
        target: LayoutNode;
    }
    export function whaterHoleLayout(params: {
        nodes: LayoutNode[];
        links: LayoutLink[];
    }): void;
    export function forceLayout(params: {
        iterations: number;
        nodes: LayoutNode[];
        links: LayoutLink[];
        preferredLinkLength: number;
    }): void;
    export function forceLayout3d(params: {
        iterations: number;
        nodes: cola.Node3D[];
        links: cola.Link3D[];
        preferredLinkLength: number;
    }): void;
    export function flowLayout(params: {
        iterations: number;
        nodes: LayoutNode[];
        links: LayoutLink[];
        preferredLinkLength: number;
    }): void;
    export function applyForceLayout(graph: GraphModel): void;
    export function applyRandomLayout(graph: GraphModel, maxDist?: number): void;
    export function applyForceLayout3d(graph: GraphModel, iterations?: number, linkLength?: number): void;
}

declare module 'l3-graph/l3Graph/utils/subscribable' {
    export interface EventObject<Key = any, Events = any> {
        eventId: Key;
        data: Events;
    }
    export type EventCallback<Events = any, Key extends keyof Events = any> = (event: EventObject<Key, Events[Key]>) => void;
    export class Subscribable<Events> {
        on<Key extends keyof Events>(eventId: Key, callback: EventCallback<Events, Key>): void;
        onAny(callback: EventCallback): void;
        unsubscribe<Key extends keyof Events>(eventId: Key, callback: EventCallback): void;
        unsubscribeFromAll(callback: EventCallback): void;
        trigger<Key extends keyof Events>(eventId: Key, eventObject?: Events[Key]): void;
    }
    export default Subscribable;
}

declare module 'l3-graph/l3Graph/utils/colorUtils' {
    export function rgbToHex(r: number, g: number, b: number): string;
    /**
        * https://gist.github.com/eyecatchup/9536706
        */
    export function HSVtoRGB(h: number, s: number, v: number): {
            r: number;
            g: number;
            b: number;
    };
    /**
        * Calculate a 32 bit FNV-1a hash
        * https://gist.github.com/vaiorabbit/5657561
        */
    export function hashFnv32a(str: string, seed?: number): number;
}

declare module 'l3-graph/l3Graph/models/widgets/widget' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { MouseHandler } from 'l3-graph/l3Graph/utils/mouseHandler';
    import { KeyHandler } from 'l3-graph/l3Graph/utils';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { GamepadHandler } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    export const DEFAULT_SELECTION_TYPE_ID = "l3graph-selection";
    export interface WidgetEvents {
        'update:widget': void;
    }
    export abstract class Widget<Events extends WidgetEvents = WidgetEvents> extends Subscribable<Events> {
        readonly widgetId: string;
        onRemove?(): void;
        forceUpdate: () => void;
    }
    export interface WidgetModelContext {
        diagramModel: DiagramModel;
        keyHandler: KeyHandler;
        mouseHandler: MouseHandler;
        gamepadHandler: GamepadHandler;
        vrManager: VrManager;
    }
    export interface WidgetViewContext<WidgetModel extends Widget = Widget> {
        diagramView: DiagramView;
        vrManager: VrManager;
        widget: WidgetModel;
    }
    export type WidgetModelResolver<WidgetModel extends Widget = Widget> = (context: WidgetModelContext) => WidgetModel;
    export type WidgetViewResolver<WidgetModel extends Widget = Widget> = (context: WidgetViewContext<WidgetModel>) => DiagramWidgetView;
    export interface WidgetFactory<WidgetModel extends Widget = any> {
        getModel: WidgetModelResolver<WidgetModel>;
        getView: WidgetViewResolver<WidgetModel>;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/gamepadsWidget' {
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GamepadHandler } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { GamepadTool } from 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools';
    export interface GamepadsWidgetProps {
        gamepadHandler: GamepadHandler;
        leftTools: GamepadTool[];
        rightTools: GamepadTool[];
    }
    export interface GamepadsTools {
        leftTool: GamepadTool;
        rightTool: GamepadTool;
    }
    export class GamepadsWidget extends Widget {
        readonly widgetId: string;
        constructor(props: GamepadsWidgetProps);
        onRemove(): void;
        readonly tools: GamepadsTools;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadsWidgetView' {
    import * as THREE from 'three';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    export interface GamepadsWidgetViewParameters {
        model: GamepadsWidget;
        vrManager: VrManager;
    }
    export class GamepadsWidgetView implements DiagramWidgetView {
        readonly model: GamepadsWidget;
        readonly mesh: THREE.Group;
        constructor(parameters: GamepadsWidgetViewParameters);
        getBoundingBox(): THREE.Box3;
        update(): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools' {
    import * as THREE from 'three';
    import { GamepadHandler, GAMEPAD_BUTTON } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    export interface GamepadToolProps {
        gamepadHandler: GamepadHandler;
        vrManager: VrManager;
    }
    export interface GamepadToolEvents {
        'update:gamepad': void;
    }
    export abstract class GamepadTool extends Subscribable<GamepadToolEvents> {
        mesh: THREE.Object3D;
        forGamepadId: number;
        constructor();
        protected forceUpdate: () => void;
        abstract onDiscard(): void;
    }
    export class LeftGamepadTool extends GamepadTool {
        protected props: GamepadToolProps;
        protected TARGET_BUTTON: GAMEPAD_BUTTON;
        constructor(props: GamepadToolProps);
        protected readonly COLOR: string;
        protected registerBearer(): void;
        protected registerHighlighter(): void;
        onDiscard(): void;
    }
    export class RightGamepadTool extends LeftGamepadTool {
        constructor(props: GamepadToolProps);
        protected TARGET_BUTTON: GAMEPAD_BUTTON;
        protected readonly COLOR: string;
        protected registerBearer(): void;
        protected registerHighlighter(): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadTools/editorTools' {
    import * as THREE from 'three';
    import { GamepadHandler, GAMEPAD_BUTTON } from 'l3-graph/l3Graph/vrUtils/gamepadHandler';
    import { EventObject } from 'l3-graph/l3Graph/utils';
    import { GamepadTool } from 'l3-graph/l3Graph/views/widgets/gamepadTools/defaultTools';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { ImageMesh } from 'l3-graph/l3Graph/views/widgets/gamepadTools/imageMesh';
    export const DISPLAY_TARGET_WIDTH = 0.2;
    export const DISPLAY_OFFSET = -5;
    export const MOC_OBJECT_RADIUS = 10;
    export const MOC_OBJECT_NEAR_MARGIN = 20;
    export interface GamepadEditorToolProps {
        gamepadHandler: GamepadHandler;
        diagramModel: DiagramModel;
        vrManager: VrManager;
    }
    export class LeftGamepadEditorTool extends GamepadTool {
        protected props: GamepadEditorToolProps;
        protected display: ImageMesh;
        protected mockObject: THREE.Object3D;
        protected readonly BUTTON_CONFIG: {
            pushMock: GAMEPAD_BUTTON;
            pullMock: GAMEPAD_BUTTON;
        };
        protected readonly COLOR: string;
        protected readonly ROTATE_Y_ANGLE: number;
        protected readonly gamepad: THREE.Group;
        constructor(props: GamepadEditorToolProps);
        setDisplayImage(displayImage: HTMLImageElement): void;
        getTargetPosition(): import("../../../models/structures").Vector3d;
        onDiscard(): void;
        protected render: () => void;
        protected onKeyPressed: (e: EventObject<"keyPressed", Map<GAMEPAD_BUTTON, Element>>) => void;
    }
    export class RightGamepadEditorTool extends LeftGamepadEditorTool {
        constructor(props: GamepadEditorToolProps);
        protected readonly BUTTON_CONFIG: {
            pushMock: GAMEPAD_BUTTON;
            pullMock: GAMEPAD_BUTTON;
        };
        protected readonly gamepad: THREE.Group;
        protected readonly COLOR: string;
        protected readonly ROTATE_Y_ANGLE: number;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/focusNodeWidget' {
    import { NodeWidget, NodeWidgetParameters } from 'l3-graph/l3Graph/models/widgets/nodeWidget';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    export interface FocusNodeWidgetParameters extends NodeWidgetParameters {
        diagramModel: DiagramModel;
    }
    export class FocusNodeWidget extends NodeWidget {
        constructor(parameters: FocusNodeWidgetParameters);
    }
}

declare module 'l3-graph/l3Graph/views/widgets/reactNodeWidgetView' {
    import * as THREE from 'three';
    import { FocusNodeWidget } from 'l3-graph/l3Graph/models/widgets/focusNodeWidget';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { DiagramWidgetView } from 'l3-graph/l3Graph/views/viewInterface';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    export interface ReactNodeWidgetViewParameters {
        diagramView: DiagramView;
        model: FocusNodeWidget;
        overlay: ReactOverlay;
        position?: OverlayPosition;
    }
    export class ReactNodeWidgetView implements DiagramWidgetView {
        readonly model: FocusNodeWidget;
        readonly mesh: THREE.Group;
        constructor(parameters: ReactNodeWidgetViewParameters);
        getBoundingBox(): THREE.Box3;
        update(): void;
        onRemove(): void;
    }
}

declare module 'l3-graph/l3Graph/views/viewInterface' {
    import * as THREE from 'three';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { AbstractOverlayAnchor } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlay3DAnchor';
    export interface View<Model = any> {
        readonly mesh: THREE.Object3D | null;
        readonly overlayAnchor3d?: AbstractOverlayAnchor3d<Model, View>;
        readonly overlayAnchor?: AbstractOverlayAnchor<Model, View>;
        getBoundingBox(): THREE.Box3;
        update(): void;
        onRemove?(): void;
        model: Model;
    }
    export type DiagramElementView = View<Node | Link>;
    export type DiagramWidgetView = View<Widget>;
}

declare module 'l3-graph/l3Graph/views/graph/overlayAnchor' {
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    import { Box } from 'l3-graph/l3Graph/models/structures';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { CSS3DSprite } from 'l3-graph/l3Graph/utils/CSS3DRenderer';
    export type OverlayPosition = 'nw' | 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w' | 'c';
    export interface OverlayAnchorEvents {
        'anchor:changed': void;
    }
    export abstract class AbstractOverlayAnchor<Model, View> extends Subscribable<OverlayAnchorEvents> {
        protected meshModel: Model;
        protected meshView: View;
        readonly html: HTMLElement;
        readonly _renderedOverlays: Map<string, HTMLElement>;
        readonly _overlayPositions: Map<string, OverlayPosition>;
        readonly sprite: CSS3DSprite;
        protected overlaysByPosition: Map<OverlayPosition, Map<string, ReactOverlay>>;
        constructor(meshModel: Model, meshView: View);
        readonly overlays: ReadonlyMap<OverlayPosition, ReadonlyMap<string, ReactOverlay>>;
        hasOverlay(owelrayId: string): boolean;
        isVisible(): boolean;
        hide(): void;
        setOverlay(overlay: ReactOverlay, position: OverlayPosition): void;
        removeOverlay(id: string): void;
        update(): void;
        protected enrichOverlay(pooreOverlay: ReactOverlay): ReactOverlay;
        protected overlayedGroup: (props: any) => JSX.Element;
        abstract getModelFittingBox(): Box;
    }
}

declare module 'l3-graph/l3Graph/defaultWidgetsSet' {
    import { SelectionWidget } from 'l3-graph/l3Graph/models/widgets/selectionWidget';
    import { ArrowHelper } from 'l3-graph/l3Graph/models/widgets/arrowHelper';
    import { WidgetFactory } from 'l3-graph/l3Graph/models/widgets/widget';
    import { GamepadsWidget } from 'l3-graph/l3Graph/models/widgets/gamepadsWidget';
    export const selectionWidgetFactory: WidgetFactory<SelectionWidget>;
    export const arrowHelperWidgetFactory: WidgetFactory<ArrowHelper>;
    export const gamepadsWidgetFactory: WidgetFactory<GamepadsWidget>;
    export const testToolFactory: WidgetFactory<any>;
    export const DEFAULT_MESH_WIDGET_SET: WidgetFactory[];
}

declare module 'l3-graph/l3Graph/vrUtils/gamepadHandler' {
    import * as THREE from 'three';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    export type Controller = THREE.Group;
    /**
      * This function should return
      * the function which restore the initial state of the highlighted mesh
      */
    export type Highlighter = (mesh: THREE.Object3D) => (mesh: THREE.Object3D) => void;
    export interface ElementBearer {
        dragKey: GAMEPAD_BUTTON;
        dragToKey: GAMEPAD_BUTTON;
        dragFromKey: GAMEPAD_BUTTON;
    }
    export interface GamepadDragEventData {
        target: Element;
        position: Vector3d;
    }
    export interface GamepadHandlerEvents {
        'keyDown': Map<GAMEPAD_BUTTON, Element | undefined>;
        'keyUp': Map<GAMEPAD_BUTTON, Element | undefined>;
        'keyPressed': Map<GAMEPAD_BUTTON, Element | undefined>;
        'elementDragStart': GamepadDragEventData;
        'elementDrag': GamepadDragEventData;
        'elementDragEnd': GamepadDragEventData;
    }
    export const GAMEPAD_EXTRA_MOVE_STEP = 10;
    export enum GAMEPAD_BUTTON {
        LEFT_NIPPLE = "LEFT_NIPPLE",
        RIGHT_NIPPLE = "RIGHT_NIPPLE",
        LEFT_TRIGGER = "LEFT_TRIGGER",
        RIGHT_TRIGGER = "RIGHT_TRIGGER",
        LEFT_GRUBBER = "LEFT_GRUBBER",
        RIGHT_GRUBBER = "RIGHT_GRUBBER",
        A = "A",
        B = "B",
        X = "X",
        Y = "Y",
        OCULUS = "OCULUS",
        MENU = "MENU"
    }
    export const OCULUS_CONTROLLERS: {
        LEFT_CONTROLLER: number;
        RIGHT_CONTROLLER: number;
    };
    export const CONTROLLERS_NUMBER: number;
    export class GamepadHandler extends Subscribable<GamepadHandlerEvents> {
        readonly keyPressed: Map<GAMEPAD_BUTTON, Element>;
        constructor(diagramModel: DiagramModel, diagramView: DiagramView);
        registerHighlighter(controller: Controller, highlighter: Highlighter): void;
        registerElementBearer(controller: Controller, bearer: ElementBearer): void;
    }
    export function attach(child: THREE.Object3D, to: THREE.Object3D, scene: THREE.Scene): void;
    export function detach(child: THREE.Object3D, parent: THREE.Object3D, scene: THREE.Scene): void;
    export function _attach(child: THREE.Object3D, scene: THREE.Scene, parent: THREE.Object3D): void;
}

declare module 'l3-graph/l3Graph/utils/htmlToSprite' {
    import * as THREE from 'three';
    import { OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Vector2d } from 'l3-graph/l3Graph/models/structures';
    export interface Rendered3dSprite {
        sprite: THREE.Sprite;
        position: OverlayPosition;
        size: Vector2d;
    }
    export function createSprite(htmlOverlay: HTMLElement, position: OverlayPosition): Promise<Rendered3dSprite>;
    export function htmlToImage(htmlElement: HTMLElement): Promise<HTMLImageElement>;
}

declare module 'l3-graph/l3Graph/models/diagramModel' {
    import { GraphModel, ImmutableMap } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { Subscribable, EventObject } from 'l3-graph/l3Graph/utils/subscribable';
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { WidgetsModel } from 'l3-graph/l3Graph/models/widgets/widgetsModel';
    import { Selection } from 'l3-graph/l3Graph/models/widgets/selection';
    export interface DiagramModelEvents {
        'syncupdate': {
            graphEvents: Set<EventObject>;
            widgetEvents: Set<EventObject>;
        };
    }
    export class DiagramModel extends Subscribable<DiagramModelEvents> {
        graph: GraphModel;
        widgetRegistry: WidgetsModel;
        selection: Selection;
        constructor();
        readonly nodes: ImmutableMap<string, Node>;
        readonly links: ImmutableMap<string, Link>;
        performSyncUpdate: () => void;
    }
}

declare module 'l3-graph/l3Graph/models/structures' {
    export interface Vector3d {
        x: number;
        y: number;
        z: number;
    }
    export interface Vector2d {
        x: number;
        y: number;
    }
    export type Size = Vector3d & {
        placeholder?: boolean;
    };
    export interface Rectangle extends Vector2d {
        width: number;
        height: number;
    }
    export interface Box extends Vector3d {
        width: number;
        height: number;
        deep: number;
    }
    export enum Object3dKind {
        Mesh = "mesh",
        Line = "line"
    }
    export type Polygon3d = [Vector3d, Vector3d, Vector3d];
    export interface Mesh {
        type: Object3dKind.Mesh;
        polygons: Polygon3d[];
    }
    export interface Line {
        type: Object3dKind.Line;
        points: Vector3d[];
    }
}

declare module 'l3-graph/l3Graph/views/graph/graphView' {
    import * as THREE from 'three';
    import { GraphModel, Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { NodeTemplateProvider, LinkTemplateProvider } from 'l3-graph/l3Graph/customization';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    import { LinkRouter } from 'l3-graph/l3Graph/utils/linkRouter';
    import { DiagramElementView } from 'l3-graph/l3Graph/views/viewInterface';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { AbstractOverlayAnchor3d } from 'l3-graph/l3Graph/views/graph/overlay3DAnchor';
    export interface GraphViewProps {
        graphModel: GraphModel;
        vrManager: VrManager;
        onAdd3dObject: (object: THREE.Object3D) => void;
        onRemove3dObject: (object: THREE.Object3D) => void;
        nodeTemplateProvider?: NodeTemplateProvider;
        linkTemplateProvider?: LinkTemplateProvider;
        simpleLinks?: boolean;
    }
    export interface GraphViewEvents {
        'overlay:down': {
            event: MouseEvent | TouchEvent;
            target: Element;
        };
    }
    export class GraphView extends Subscribable<GraphViewEvents> {
        views: Map<string, DiagramElementView>;
        anchors3d: Set<AbstractOverlayAnchor3d<any, any>>;
        graphModel: GraphModel;
        meshHtmlContainer: HTMLElement;
        overlayHtmlContainer: HTMLElement;
        linkRouter: LinkRouter;
        constructor(props: GraphViewProps);
        registerElement(element: Element): DiagramElementView;
        removeElementView(element: Element): void;
        update(specificIds: string[]): void;
    }
}

declare module 'l3-graph/l3Graph/views/widgets/widgetsView' {
    import * as THREE from 'three';
    import { WidgetsModel } from 'l3-graph/l3Graph/models/widgets/widgetsModel';
    import { WidgetViewResolver, Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    import { VrManager } from 'l3-graph/l3Graph/vrUtils/vrManager';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    export interface WidgetsViewProps {
        diagramView: DiagramView;
        vrManager: VrManager;
        widgetsModel: WidgetsModel;
        onAdd3dObject: (object: THREE.Object3D) => void;
        onRemove3dObject: (object: THREE.Object3D) => void;
    }
    export class WidgetsView {
        diagramView: DiagramView;
        vrManager: VrManager;
        widgetsModel: WidgetsModel;
        constructor(props: WidgetsViewProps);
        registerViewResolver(widgetId: string, viewResolver: WidgetViewResolver): void;
        registerWidgetViewForModel(widget: Widget): void;
        removeWidgetViewOfModel(widget: Widget): void;
        update(specificIds?: string[]): void;
    }
}

declare module 'l3-graph/l3Graph/vrUtils/webVr' {
    import * as THREE from 'three';
    export interface UndocumentedOptions {
        frameOfReferenceType: any;
    }
    export interface WebGLRenderer extends THREE.WebGLRenderer {
        vr: ThreejsVrManager;
    }
    export interface ThreejsVrManager extends THREE.WebVRManager {
        setSession: (session: Session) => void;
        getController: (index: number) => THREE.Group;
        scaleFactor: number;
    }
    export type Device = VRDisplay & {
        isPresenting: boolean;
        exitPresent: () => void;
        requestPresent: (presenters: {
            source: HTMLCanvasElement;
        }[]) => void;
        requestSession: (options: {
            immersive: boolean;
            exclusive: boolean;
        }) => Promise<Session>;
        supportsSession: (options: {
            immersive: boolean;
            exclusive: boolean;
        }) => Promise<void>;
    };
    export interface VrEvent extends Event {
        display: Device;
    }
    export interface Session {
        addEventListener: (eventId: string, handler: (event: Event) => void) => void;
        removeEventListener: (eventId: string, handler: (event: Event) => void) => void;
        end: () => void;
    }
    export interface XrNavigator extends Navigator {
        xr: {
            requestDevice: () => Promise<Device>;
        };
    }
    export interface CompleteNavigator extends Navigator {
        webkitGetGamepads: () => Gamepad[];
    }
    export function isXrNavigator(n: Navigator): n is XrNavigator;
    export function isWebkitNavigator(n: Navigator): n is CompleteNavigator;
}

declare module 'l3-graph/l3Graph/vrUtils/vrManager' {
    import Subscribable from 'l3-graph/l3Graph/utils/subscribable';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    export interface VrManagerEvents {
        'presenting:state:changed': void;
        'connection:state:changed': void;
    }
    export class VrManager extends Subscribable<VrManagerEvents> {
        constructor(view: DiagramView);
        readonly errors: string[];
        readonly isStarted: boolean;
        readonly isConnected: boolean;
        readonly camera: import("three").PerspectiveCamera | import("three").ArrayCamera;
        getController(id: number): import("three").Group;
        start(): void;
        stop(): void;
        connect(): Promise<void>;
    }
}

declare module 'l3-graph/l3Graph/utils/CSS3DRenderer' {
    import * as THREE from 'three';
    /**
      * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
      * @author mrdoob / http://mrdoob.com/
      * @author yomotsu / https://yomotsu.net/
      */
    export class CSS3DObject extends THREE.Object3D {
        element: HTMLElement;
        constructor(element: HTMLElement);
    }
    export class CSS3DSprite extends CSS3DObject {
        element: HTMLElement;
        constructor(element: HTMLElement);
    }
    export class CSS3DRenderer {
        _width: number;
        _height: number;
        _widthHalf: number;
        _heightHalf: number;
        matrix: THREE.Matrix4;
        cache: {
            camera: {
                fov: number;
                style: string;
            };
            objects: WeakMap<object, any>;
        };
        domElement: HTMLDivElement;
        cameraElement: HTMLDivElement;
        isIE: boolean;
        constructor();
        getSize(): {
            width: number;
            height: number;
        };
        setSize(width: number, height: number): void;
        render(scene: THREE.Scene, camera: THREE.Camera): void;
    }
}

declare module 'l3-graph/l3Graph/models/point' {
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    import { Subscribable } from 'l3-graph/l3Graph/utils';
    export interface PointParameters {
        position: Vector3d;
    }
    export interface PointEvents {
        'change:position': Vector3d;
    }
    export abstract class Point<Events extends PointEvents = PointEvents> extends Subscribable<Events> {
        readonly id: string;
        protected _position: Vector3d;
        constructor(parameters: PointParameters);
        readonly position: Vector3d;
        setPosition(position: Vector3d): void;
    }
}

declare module 'l3-graph/l3Graph/customization/defaultLinkTemplate' {
    import { LinkViewTemplate, LinkTemplateProvider } from 'l3-graph/l3Graph/customization';
    export const DEFAULT_LINK_TEMPLATE: LinkViewTemplate;
    export const DEFAULT_LINK_TEMPLATE_PROVIDER: LinkTemplateProvider;
}

declare module 'l3-graph/l3Graph/customization/defaultNodeTemplate' {
    import { NodeViewTemplate, NodeTemplateProvider } from 'l3-graph/l3Graph/customization/templates';
    export const DEFAULT_NODE_TEMPLATE: NodeViewTemplate<{
        label: string;
    }>;
    export const DEFAULT_NODE_TEMPLATE_PROVIDER: NodeTemplateProvider<{
        label: string;
    }>;
}

declare module 'l3-graph/l3Graph/customization/defaultOverlay' {
    import * as React from 'react';
    import { ReactOverlay } from 'l3-graph/l3Graph/customization';
    export const DEFAULT_LINK_OVERLAY: ReactOverlay;
    export const DEFAULT_NODE_OVERLAY: ReactOverlay;
    export function createContextProvider(context: any): React.ComponentClass;
    export function enrichOverlay<Data>(pooreOverlay: ReactOverlay<Data>, data: Data): ReactOverlay<Data>;
}

declare module 'l3-graph/l3Graph/customization/mesh' {
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    export enum MeshKind {
        Obj = "obj",
        Primitive = "primitive",
        ThreeNative = "three-native"
    }
    export namespace THREE {
        type Object3D = any;
    }
    export interface Mesh {
        color?: string | number;
        texture?: string;
        preserveRatio?: boolean;
        size?: Vector3d;
    }
    export interface MeshNative extends Mesh {
        type: MeshKind.ThreeNative;
        mesh: THREE.Object3D;
    }
    export interface MeshObj extends Mesh {
        type: MeshKind.Obj;
        markup: string;
    }
    export interface MeshPrimitive extends Mesh {
        type: MeshKind.Primitive;
        shape: 'cube' | 'sphere' | 'cone' | 'cylinder' | 'dodecahedron' | 'torus' | 'tetrahedron' | 'plane';
    }
    export type L3Mesh = MeshNative | MeshObj | MeshPrimitive;
}

declare module 'l3-graph/l3Graph/customization/templates' {
    import * as React from 'react';
    import { L3Mesh } from 'l3-graph/l3Graph/customization/mesh';
    export interface ReactOverlay<ReactProps = any> {
        id: string;
        value: React.ReactElement<ReactProps>;
        context?: any;
    }
    export interface NodeViewTemplate<Content = any> {
        overlay?: ReactOverlay<Content>;
        mesh?: () => L3Mesh;
    }
    export interface LinkViewTemplate {
        color: number | string;
        thickness?: number;
        overlay?: ReactOverlay<{
            label: string;
        }>;
    }
    export type NodeTemplateProvider<Content = any> = (data: Content) => NodeViewTemplate;
    export type LinkTemplateProvider<Content = any> = (data: Content) => LinkViewTemplate;
}

declare module 'l3-graph/l3Graph/utils/mouseHandler' {
    import * as THREE from 'three';
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { DiagramView } from 'l3-graph/l3Graph/views/diagramView';
    import { Vector2d } from 'l3-graph/l3Graph/models/structures';
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    export const MIN_DRAG_OFFSET = 5;
    export interface HandlerElementClickEvent {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        element: Element;
    }
    export interface HandlerDragElementEvent {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        element: Element;
    }
    export interface HandlerDragEvent {
        nativeEvent: MouseEvent | MouseWheelEvent | TouchEvent;
        offset: Vector2d;
    }
    export interface MouseHandlerEvents {
        'elementScroll': HandlerElementClickEvent;
        'paperScroll': MouseWheelEvent;
        'elementClick': HandlerElementClickEvent;
        'paperClick': MouseEvent | TouchEvent;
        'elementStartDrag': HandlerDragElementEvent;
        'elementDrag': HandlerDragElementEvent;
        'elementEndDrag': HandlerDragElementEvent;
        'paperStartDrag': HandlerDragEvent;
        'paperDrag': HandlerDragEvent;
        'paperEndDrag': HandlerDragEvent;
    }
    export class MouseHandler extends Subscribable<MouseHandlerEvents> {
        constructor(diagramhModel: DiagramModel, diagramView: DiagramView);
        readonly isPanning: boolean;
        readonly isDragging: boolean;
        readonly draggedElement: Element | undefined;
        fireMouseDownEvent(event: MouseEvent | TouchEvent, element?: Element): void;
        fireScrollEvent(event: MouseWheelEvent, element?: Element): void;
    }
    export function mapMeshes(diagramhModel: DiagramModel, diagramView: DiagramView): {
        meshes: THREE.Object3D[];
        nodeMeshMap: Element[];
    };
    export function handleDragging(downEvent: MouseEvent | TouchEvent, onChange: (event: MouseEvent | TouchEvent, change: Vector2d) => void, onEnd?: (event: MouseEvent | TouchEvent, change?: Vector2d) => void): void;
}

declare module 'l3-graph/l3Graph/utils' {
    export * from 'l3-graph/l3Graph/utils/colorUtils';
    export * from 'l3-graph/l3Graph/utils/keyHandler';
    export * from 'l3-graph/l3Graph/utils/shapeUtils';
    export * from 'l3-graph/l3Graph/utils/subscribable';
    export * from 'l3-graph/l3Graph/utils/geometry';
    /** Generates random 32-digit hexadecimal string. */
    export function generate128BitID(): string;
}

declare module 'l3-graph/l3Graph/views/widgets/gamepadTools/imageMesh' {
    import * as THREE from 'three';
    import { Vector2d } from 'l3-graph/l3Graph/models/structures';
    export interface ImageMeshParameters {
        size?: Partial<Vector2d>;
        image?: HTMLImageElement;
    }
    export class ImageMesh extends THREE.Group {
        constructor(parameters?: ImageMeshParameters);
        setImage(image: HTMLImageElement | undefined): void;
        setPreferredSize(size: Vector2d | undefined): void;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/nodeWidget' {
    import { Node } from 'l3-graph/l3Graph/models/graph/node';
    import { WidgetEvents, Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    export interface NodeWidgetEvents extends WidgetEvents {
        'change:focus': Node;
    }
    export interface NodeWidgetParameters {
        widgetId: string;
    }
    export abstract class NodeWidget extends Widget {
        readonly widgetId: string;
        constructor(parameters: NodeWidgetParameters);
        setFocusNode(target: Node | undefined): void;
        readonly isFocusNodeChanged: boolean;
        readonly focusNode: Node;
        readonly prevFocusNode: Node;
        onRemove(): void;
    }
}

declare module 'l3-graph/l3Graph/views/graph/overlay3DAnchor' {
    import * as THREE from 'three';
    import { Rendered3dSprite } from 'l3-graph/l3Graph/utils/htmlToSprite';
    import { AbstractOverlayAnchor, OverlayPosition } from 'l3-graph/l3Graph/views/graph/overlayAnchor';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    export abstract class AbstractOverlayAnchor3d<Model, View> {
        protected meshModel: Model;
        protected meshView: View;
        protected overlayAnchor: AbstractOverlayAnchor<Model, View>;
        readonly mesh: THREE.Object3D;
        sprites: Rendered3dSprite[];
        constructor(meshModel: Model, meshView: View, overlayAnchor: AbstractOverlayAnchor<Model, View>);
        update(): void;
        abstract forceUpdate(): void;
        abstract updatePosition(): void;
        abstract placeSprites(sprites: Rendered3dSprite[]): void;
    }
    export function applyOffset(basicVector: Vector3d, offset: Vector3d, position: OverlayPosition): Vector3d;
}

declare module 'l3-graph/l3Graph/models/widgets/selectionWidget' {
    import { Element } from 'l3-graph/l3Graph/models/graph/graphModel';
    import { DiagramModel } from 'l3-graph/l3Graph/models/diagramModel';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    export interface SelectionParameters {
        diagramModel: DiagramModel;
    }
    export class SelectionWidget extends Widget {
        readonly widgetId: string;
        constructor(parameters: SelectionParameters);
        readonly selectedElements: Element[];
    }
}

declare module 'l3-graph/l3Graph/models/widgets/arrowHelper' {
    import { NodeWidget } from 'l3-graph/l3Graph/models/widgets/nodeWidget';
    import { MouseHandler } from 'l3-graph/l3Graph/utils/mouseHandler';
    export interface ArrowHelperParameters {
        mouseHandler: MouseHandler;
    }
    export class ArrowHelper extends NodeWidget {
        constructor(parameters: ArrowHelperParameters);
        readonly isVisible: boolean;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/widgetsModel' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Widget } from 'l3-graph/l3Graph/models/widgets/widget';
    export interface WidgetsModelEvents {
        'add:widget': Widget;
        'remove:widget': Widget;
        'update:widget': Widget;
    }
    export class WidgetsModel extends Subscribable<WidgetsModelEvents> {
        readonly widgets: ReadonlyMap<string, Widget>;
        registerWidget(widget: Widget): void;
        removeWidget(widget: Widget): void;
    }
}

declare module 'l3-graph/l3Graph/models/widgets/selection' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    import { Element, GraphModel } from 'l3-graph/l3Graph/models/graph/graphModel';
    export interface SelectionParameters {
        selection?: Set<Element>;
        graph: GraphModel;
    }
    export interface SelectionEvents {
        'change': ReadonlySet<Element>;
    }
    export class Selection extends Subscribable<SelectionEvents> {
        readonly widgetId: string;
        constructor(parameters: SelectionParameters);
        setSelection(elements: ReadonlySet<Element>): void;
        readonly elements: ReadonlySet<Element>;
    }
}

declare module 'l3-graph/l3Graph/utils/linkRouter' {
    import { Link } from 'l3-graph/l3Graph/models/graph/link';
    import { Vector3d } from 'l3-graph/l3Graph/models/structures';
    export interface LinkRouter {
            getRout(link: Link): Vector3d[];
    }
    export class DefaultLinkRouter implements LinkRouter {
            getRout(link: Link): Vector3d[];
    }
    /**
        * @param polyline
        * @param offset from 0 to 1
        */
    export function getPointAlongPolylineByRatio(polyline: ReadonlyArray<Vector3d>, ratio: number): Vector3d;
    /**
        * @param polyline
        * @param offset from 0 to length of polyline
        */
    export function getPointAlongPolyline(polyline: ReadonlyArray<Vector3d>, offset: number): Vector3d;
    export function computePolylineLength(polyline: ReadonlyArray<Vector3d>): number;
}

declare module 'l3-graph/l3Graph/utils/keyHandler' {
    import { Subscribable } from 'l3-graph/l3Graph/utils/subscribable';
    export interface KeyHandlerEvents {
        'keyDown': Set<number>;
        'keyPressed': Set<number>;
        'keyUp': Set<number>;
    }
    export const KEY_CODES: {
        UP: number;
        DOWN: number;
        LEFT: number;
        RIGHT: number;
        SPACE: number;
        CTRL: number;
        PLUS: number;
        MINUS: number;
        DELETE: number;
        ESCAPE: number;
    };
    export class KeyHandler extends Subscribable<KeyHandlerEvents> {
        switchOn(): void;
        switchOff(): void;
    }
    export interface CancellationEvents {
        'cancel': void;
    }
    export class Cancellation extends Subscribable<CancellationEvents> {
        isCancelled: boolean;
        stop(): void;
    }
    export function animationFrameInterval(intervalCallback: () => void): Cancellation;
}

declare module 'l3-graph/l3Graph/utils/shapeUtils' {
    import * as THREE from 'three';
    import { MeshPrimitive, MeshObj } from 'l3-graph/l3Graph/customization';
    export function preparePrimitive(primitive: MeshPrimitive): THREE.Mesh;
    export function prepareMesh(meshObj: MeshObj): THREE.Object3D;
    /** Helper only for phong and line basic material */
    export function setColor(mesh: THREE.Object3D, providedColor: string | number | Map<THREE.Object3D, string | number>): void;
    export function setMaterial(mesh: THREE.Object3D, material: THREE.Material): void;
    export function backupColors(mesh: THREE.Object3D): Map<THREE.Object3D, THREE.Material | THREE.Material[]>;
    export function restoreColors(mesh: THREE.Object3D, backUp: Map<THREE.Object3D, THREE.Material | THREE.Material[]>): void;
}

declare module 'l3-graph/l3Graph/utils/geometry' {
    import * as THREE from 'three';
    import { Vector3d, Vector2d, Size } from 'l3-graph/l3Graph/models/structures';
    export function vector3dToTreeVector3(v: Vector3d): THREE.Vector3;
    export function threeVector3ToVector3d(v: THREE.Vector3): Vector3d;
    export function calcBounds(points: Vector3d[]): {
        min: Vector3d;
        max: Vector3d;
        average: Vector3d;
    };
    export function normalize(vector: Vector3d): Vector3d;
    export function length(from: Vector3d | Vector2d): number;
    export function vectorLength({ x, y, z }: Vector3d): number;
    export function distance(from: Vector3d | Vector2d, to: Vector3d | Vector2d): number;
    export function inverse(vector: Vector3d): Vector3d;
    export function multiply(vector: Vector3d, k: number): Vector3d;
    export function sum(vector1: Vector3d, vector2: Vector3d): Vector3d;
    export function sub(vector1: Vector3d, vector2: Vector3d): Vector3d;
    export function normalLeft(vector: Vector3d): {
        x: number;
        y: number;
        z: number;
    };
    export function normalUp(vector: Vector3d): Vector3d;
    export function normalDown(vector: Vector3d): Vector3d;
    export function normalRight(vector: Vector3d): Vector3d;
    export function eventToPosition(event: MouseEvent | TouchEvent, viewBox?: ClientRect | DOMRect): Vector2d | undefined;
    export function getModelFittingBox({ x, y, z }: Size): {
        width: number;
        height: number;
        deep: number;
    };
}

